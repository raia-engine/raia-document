# lua_pcall

保護モードで関数を呼び出します。エラーが発生した場合、エラーコードを返します。

`[-(nargs + 1), +(nresults|1), -]`

```c
int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
```

## 説明

保護モードで関数を呼び出します。

`nargs`と`nresults`は`lua_call`と同じ意味を持ちます。呼び出し中にエラーがなければ、`lua_pcall`は`lua_call`と全く同じように振る舞います。しかし、エラーが発生した場合、`lua_pcall`はそれをキャッチし、スタックに単一の値（エラーメッセージ）をプッシュし、エラーコードを返します。`lua_call`と同様に、`lua_pcall`は常に関数とその引数をスタックから削除します。

`errfunc`が0の場合、スタックに返されるエラーメッセージは元のエラーメッセージと完全に同じです。それ以外の場合、`errfunc`はエラーハンドラ関数のスタックインデックスです。（現在の実装では、このインデックスは擬似インデックスにはなり得ません。）ランタイムエラーの場合、この関数はエラーメッセージと共に呼び出され、その返り値が`lua_pcall`によってスタックに返されるメッセージになります。

通常、エラーハンドラ関数はエラーメッセージにさらなるデバッグ情報（スタックトレースなど）を追加するために使用されます。このような情報は`lua_pcall`の戻り後には収集できません。その時点ではすでにスタックが巻き戻されています。

`lua_pcall`関数は成功の場合に0を返します。または以下のエラーコードのいずれか（lua.hで定義）を返します：

- `LUA_ERRRUN`: ランタイムエラー。
- `LUA_ERRMEM`: メモリ割り当てエラー。この種のエラーに対しては、Luaはエラーハンドラ関数を呼び出しません。
- `LUA_ERRERR`: エラーハンドラ関数の実行中にエラーが発生しました。

## サンプルコード

```c
int status = lua_pcall(L, 2, 1, 0);
if (status != 0) {
    fprintf(stderr, "エラー: %s\n", lua_tostring(L, -1));
    lua_pop(L, 1);
}
```

このコードは、関数を保護モードで呼び出し、エラーが発生した場合にエラーメッセージを出力します。

## 互換性

- Lua5.1

## 関連項目

- lua_call
- lua_cpcall