# Lua 5.2 リファレンスマニュアル

執筆者: Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes  
著作権 © 2011–2013 Lua.org, PUC-Rio. Luaライセンスの条件のもと、無料で提供されています。

[[TOC]]

## 1 - はじめに

Luaは、データ記述の機能を備えた汎用的な手続き型プログラミングをサポートする拡張プログラミング言語です。また、オブジェクト指向プログラミング、関数型プログラミング、データ駆動型プログラミングにも優れたサポートを提供しています。Luaは、スクリプト言語を必要とする任意のプログラムのための、強力かつ軽量で埋め込み可能なスクリプト言語として設計されています。LuaはクリーンなCコードで書かれたライブラリとして実装されており、Standard CとC++の共通部分で構成されています。

Luaは拡張言語であるため、「メイン」プログラムという概念はありません。常にホストとなるクライアントプログラム内で埋め込まれ、その中で動作します。ホストプログラムはLuaコードを実行するために関数を呼び出したり、Luaの変数を読み書きしたり、Luaコードから呼び出されるC関数を登録したりすることができます。C関数を使用することで、Luaは多様な領域に対応できるように拡張でき、同じ構文フレームワークを共有するカスタマイズされたプログラミング言語を作成できます。Luaの配布には、Luaライブラリを利用して対話型またはバッチ処理に対応する完全な独立したLuaインタプリタである「lua」というサンプルホストプログラムが含まれています。

Luaはフリーソフトウェアであり、通常の保証はなく、ライセンスに明記された通り提供されます。このマニュアルで説明されている実装は、Luaの公式ウェブサイト [www.lua.org](http://www.lua.org) で入手可能です。

この文書は他のリファレンスマニュアルと同様、読みにくい箇所があるかもしれません。Luaの設計に関する決定については、Luaのウェブサイトにある技術論文を参照してください。また、Luaでのプログラミングに関する詳細な入門書として、Robertoの著書『Programming in Lua』があります。

## 2 - 基本概念

このセクションでは、Lua言語の基本的な概念について説明します。

### 2.1 - 値と型

Luaは動的型付け言語です。これは、変数自体に型がないことを意味し、型は値にのみ関連付けられます。言語内に型の定義は存在せず、すべての値はその型情報を持っています。

Luaのすべての値は「第一級の値」です。つまり、すべての値は変数に格納でき、他の関数への引数として渡したり、結果として返したりすることができます。

Luaには8つの基本的な型があります: `nil`、`boolean`、`number`、`string`、`function`、`userdata`、`thread`、および `table` です。`nil`は、他のすべての値と異なる特性を持ち、通常は有効な値がないことを示します。`boolean`は`false`と`true`の値を持つ型で、`nil`と`false`は条件を`false`にし、他の値はすべて`true`にします。`number`は実数（倍精度浮動小数点数）を表します。数値に対する操作は、通常IEEE 754規格に準拠しているCの実装ルールに従います。（単精度浮動小数点数や長整数など、他の内部表現を使用するLuaインタプリタも簡単に作成できます。詳細は`luaconf.h`ファイルを参照してください）。`string`は不変のバイト列を表します。Luaは8ビットに対応しているため、文字列には埋め込みゼロ（`\0`）を含む任意の8ビット値が含まれます。

Luaは、Luaで書かれた関数とCで書かれた関数の両方を呼び出し操作できます（詳細は§3.4.9を参照してください）。

`userdata`型は、任意のCデータをLua変数に格納するために提供されており、`userdata`値は生のメモリブロックへのポインタです。`userdata`には、Luaによって管理されるフル`userdata`と、ホストによって管理される軽量`userdata`の2種類があります。`userdata`にはLua内で事前定義された操作はなく、代入と同一性テストのみがサポートされています。メタテーブルを使用することで、プログラマはフル`userdata`に対する操作を定義できます（詳細は§2.4を参照してください）。`userdata`はLua内で生成または変更できず、C APIを通じてのみ操作可能です。これにより、ホストプログラムが所有するデータの整合性が保証されます。

`thread`型は独立した実行スレッドを表し、コルーチンを実装するために使用されます（詳細は§2.6を参照してください）。Luaのスレッドとオペレーティングシステムのスレッドは異なるものです。Luaは、OSのスレッドサポートがないシステムでもコルーチンを利用できます。

`table`型は、連想配列（配列のインデックスに数字だけでなく、任意のLua値（ただし`nil`と`NaN`を除く）を使用できる配列）を実装します。`table`は異種データ（異なる型の値）を含むことができ、キーの値が`nil`のエントリはテーブルの一部とみなされません。反対に、テーブルの一部でないキーには`nil`の値が関連付けられます。

Luaにおける`table`は唯一のデータ構造化機構であり、通常の配列、シーケンス、シンボルテーブル、集合、レコード、グラフ、ツリーなどを表現できます。レコードを表現するために、Luaではフィールド名をインデックスとして使用します。この言語では`a.name`という記法を`a["name"]`の簡略形として提供しています。Luaにはテーブルを作成するための便利な方法がいくつかあります（詳細は§3.4.8を参照してください）。

`シーケンス`という用語は、{1..n}という形で全ての正の数値キーを持つテーブルを指し、nはシーケンスの長さと呼ばれます（詳細は§3.4.6を参照してください）。

テーブルのフィールドの値は、関数が第一級の値であるため、任意の型であることができます。したがって、テーブルにはメソッド（関数）を含めることができます（詳細は§3.4.10を参照してください）。

テーブルのインデックスは、Luaの生の等価性定義に従います。式`a[i]`と`a[j]`は、iとjが生で等しい（メタメソッドを使用しない等価である）場合にのみ同じテーブル要素を指します。

テーブル、関数、スレッド、そして（フル）userdataの値は「オブジェクト」です。これらの値を変数に直接含むのではなく、参照として扱います。代入、パラメータの受け渡し、および関数の戻り値は常に参照を操作し、これらの操作はコピーを伴いません。

ライブラリ関数`type`は、指定された値の型を示す文字列を返します（詳細は§6.1を参照してください）。

### 2.2 - 環境とグローバル環境

§3.2と§3.3.3で詳しく説明されるように、グローバル名 `var` への参照は、構文的に `_ENV.var` へと変換されます。また、すべてのチャンク（Luaコードの一塊）は、外部のローカル変数 `_ENV` のスコープ内でコンパイルされるため（§3.3.2参照）、チャンク内で `_ENV` 自体がグローバル名になることはありません。

この外部変数 `_ENV` の存在やグローバル名の変換にもかかわらず、`_ENV` は通常の変数名として扱えます。具体的には、この名前で新しい変数やパラメータを定義することができます。プログラム内でグローバル名にアクセスするときには、Luaの通常の可視性ルールに従って、その時点で見える `_ENV` が使用されます（§3.5参照）。

`_ENV` に割り当てられたテーブルは「環境」と呼ばれます。

Luaは「グローバル環境」と呼ばれる特別な環境を保持しています。この値は、Cレジストリ内の特別なインデックスに保持されます（§4.5参照）。Luaでは、このグローバル環境と同じ値で変数 `_G` が初期化されます。

Luaがチャンクをコンパイルする際、そのチャンクの `_ENV` アップバリュー（上位値）をグローバル環境で初期化します（`load` 参照）。したがって、デフォルトでは、Luaコード内のグローバル変数はグローバル環境のエントリを参照します。また、すべての標準ライブラリはグローバル環境にロードされており、いくつかの関数はこの環境で操作を行います。`load` や `loadfile` を使用すると、異なる環境でチャンクを読み込むことができます。（C言語では、チャンクを読み込んだ後で最初のアップバリューの値を変更する必要があります）。

Cコードやデバッグライブラリを通じてレジストリ内のグローバル環境を変更すると、変更後に読み込まれたチャンクは新しい環境を取得します。しかし、以前に読み込まれたチャンクには影響がありません。これは、それぞれが自身の `_ENV` 変数内に環境への参照を持っているためです。また、Luaは変数 `_G`（元のグローバル環境に格納されている）を更新しません。

### 2.3 - エラーハンドリング

Luaは埋め込み型の拡張言語であるため、すべてのLuaの動作はホストプログラム内のCコードがLuaライブラリからの関数を呼び出すことから始まります（`lua_pcall`参照）。Luaチャンクのコンパイルや実行中にエラーが発生すると、制御はホストプログラムに戻され、適切な処理（例: エラーメッセージの表示）を行うことができます。

Luaコード内で明示的にエラーを発生させるには、`error` 関数を使用します。Luaでエラーをキャッチする必要がある場合、`pcall` または `xpcall` を使って特定の関数を保護モードで呼び出すことができます。

エラーが発生すると、エラーに関する情報を持ったエラーオブジェクト（エラーメッセージとも呼ばれます）が伝播されます。Lua自体はエラーオブジェクトが文字列のエラーのみを生成しますが、プログラムはエラーオブジェクトに任意の値を使用してエラーを生成することが可能です。

`xpcall` または `lua_pcall` を使用する際、エラー発生時に呼び出されるメッセージハンドラを指定することができます。この関数は元のエラーメッセージを受け取り、新しいエラーメッセージを返します。この関数はエラーがスタックを巻き戻す前に呼び出されるため、スタックのトレースバックを生成するなど、エラーに関するさらなる情報を収集できます。このメッセージハンドラも保護された呼び出しによって保護されるため、メッセージハンドラ内でエラーが発生すると再びメッセージハンドラが呼ばれます。このループが続くと、Luaはそれを停止し、適切なメッセージを返します。

### 2.4 - メタテーブルとメタメソッド

Luaのすべての値はメタテーブルを持つことができます。メタテーブルは通常のLuaテーブルで、特定の操作時に元の値の動作を定義します。メタテーブルの特定のフィールドを設定することで、値に対する操作のいくつかの挙動を変更できます。例えば、数値でない値を足し算の演算子のオペランドとして使用すると、Luaはその値のメタテーブルの"__add"フィールドに関数があるかどうかを確認します。関数が見つかれば、その関数が足し算を実行します。

メタテーブルのキーはイベント名から派生しており、対応する値はメタメソッドと呼ばれます。前述の例では、イベントは"add"で、メタメソッドは足し算を行う関数です。

メタテーブルは`getmetatable`関数で確認できます。

テーブルのメタテーブルは`setmetatable`関数で置き換えることができますが、他の型のメタテーブルはLuaから変更できません（デバッグライブラリを除く）。これにはC APIを使用する必要があります。

テーブルとフルユーザデータは個別のメタテーブルを持つことができますが、他のすべての型は同じ型の値で1つのメタテーブルを共有します。つまり、すべての数値や文字列に対して1つのメタテーブルが存在します。デフォルトでは値にメタテーブルはありませんが、文字列ライブラリは文字列型にメタテーブルを設定します（§6.4参照）。

メタテーブルは、算術演算、順序比較、連結、長さ操作、インデックス参照時のオブジェクトの挙動を制御できます。また、ユーザデータやテーブルがガベージコレクションされる際に呼び出される関数も定義できます。Luaがこれらの操作を値に対して実行する際、その値に対応するイベントのメタメソッドがあるメタテーブルが存在するかを確認します。存在する場合、Luaはそのメタメソッドを使用して操作を行います。

以下に挙げる操作はメタテーブルによって制御されます。各操作には対応する名前があり、キーにはその名前の前に2つのアンダースコア「__」が付けられています。例えば、「add」操作のキーは文字列"__add"です。

操作の詳細な説明として、Luaインタープリタが操作をどのように実行するかを示すLua関数を用います。ここに示すLuaコードはあくまで説明用で、実際の動作はインタープリタにハードコードされており、はるかに効率的です。説明で使用する関数（`rawget`、`tonumber`など）は§6.1で説明されています。特に、あるオブジェクトのメタメソッドを取得するには以下の表現を使用します：

     metatable(obj)[event]

これは次のように解釈されます：

     rawget(getmetatable(obj) or {}, event)

これにより、メタメソッドへのアクセスが他のメタメソッドを呼び出さず、メタテーブルのないオブジェクトへのアクセスがエラーとならずに`nil`を返します。

単項の「-」や「#」演算子の場合、メタメソッドはダミーの第2引数と共に呼び出されます。この追加引数はLuaの内部処理を簡素化するためのものであり、将来のバージョンで削除される可能性があるため、以下のコードには含まれていません。（ほとんどの場合、この追加引数は無関係です。）

- **"add"**: `+` 演算。以下の`getbinhandler`関数は、Luaが二項演算のためのハンドラをどのように選択するかを定義します。最初に第1オペランドを確認し、その型にハンドラが定義されていない場合は第2オペランドを確認します。

     ```lua
     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
     ```

  この関数を使用すると、`op1 + op2` の動作は次のようになります：

     ```lua
     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- 両方のオペランドが数値か？
         return o1 + o2   -- "+" はここで基本の "add" 演算
       else  -- 少なくとも一方のオペランドが数値でない場合
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- 両オペランドを引数にしてハンドラを呼び出す
           return (h(op1, op2))
         else  -- ハンドラが見つからない場合: デフォルトの挙動
           error("エラー")
         end
       end
     end
     ```

- **"sub"**: `-` 演算。`add`演算と同様の動作です。
- **"mul"**: `*` 演算。`add`演算と同様の動作です。
- **"div"**: `/` 演算。`add`演算と同様の動作です。
- **"mod"**: `%` 演算。`add`演算と同様ですが、基本の演算は `o1 - floor(o1 / o2) * o2` です。
- **"pow"**: `^`（べき乗）演算。`add`演算と同様ですが、基本の演算はCのmathライブラリにある`pow`関数です。
- **"unm"**: 単項`-`演算。

     ```lua
     function unm_event(op)
       local o = tonumber(op)
       if o then  -- オペランドが数値か？
         return -o  -- '-' はここで基本の "unm" 演算
       else  -- オペランドが数値でない場合
         local h = metatable(op).__unm
         if h then
           -- オペランドを引数にしてハンドラを呼び出す
           return (h(op))
         else  -- ハンドラが見つからない場合: デフォルトの挙動
           error("エラー")
         end
       end
     end
     ```

- **"concat"**: `..`（連結）演算。

     ```lua
     function concat_event(op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- 基本の文字列連結
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error("エラー")
         end
       end
     end
     ```

- **"len"**: `#`（長さ）演算。

     ```lua
     function len_event(op)
       if type(op) == "string" then
         return strlen(op)      -- 基本の文字列長
       else
         local h = metatable(op).__len
         if h then
           return (h(op))       -- ハンドラをオペランドと共に呼び出す
         elseif type(op) == "table" then
           return #op           -- 基本のテーブルの長さ
         else  -- ハンドラが見つからない場合: エラー
           error("エラー")
         end
       end
     end
     ```

  テーブルの長さに関する詳細は、§3.4.6を参照してください。

- **"eq"**: `==`（等価）演算。`getequalhandler`関数はLuaが等価のためのメタメソッドをどのように選択するかを定義します。比較される両方の値が同じ型を持ち、比較される操作に同じメタメソッドを持つ場合のみ、メタメソッドが選択されます。また、比較対象の値はテーブルまたはフルユーザデータでなければなりません。

     ```lua
     function getequalhandler(op1, op2)
       if type(op1) ~= type(op2) or
          (type(op1) ~= "table" and type(op1) ~= "userdata") then
         return nil     -- 異なる値
       end
       local mm1 = metatable(op1).__eq
       local mm2 = metatable(op2).__eq
       if mm1 == mm2 then return mm1 else return nil end
     end
     ```

  **"eq"**イベントは以下のように定義されています：

     ```lua
     function eq_event(op1, op2)
       if op1 == op2 then   -- 基本の等価判定
         return true        -- 値が等しい
       end
       -- メタメソッドを試す
       local h = getequalhandler(op1, op2)
       if h then
         return not not h(op1, op2)
       else
         return false
       end
     end
     ```

  結果は常にブール値です。

- **"lt"**: `<`（小なり）演算。

     ```lua
     function lt_event(op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 < op2   -- 数値の比較
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 < op2   -- 辞書順比較
       else
         local h = getbinhandler(op1, op2, "__lt")
         if h then
           return not not h(op1, op2)
         else
           error("エラー")
         end
       end
     end
     ```

  結果は常にブール値です。

- **"le"**: `<=`（小なりまたは等しい）演算。

     ```lua
     function le_event(op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 <= op2   -- 数値の比較
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 <= op2   -- 辞書順比較
       else
         local h = getbinhandler(op1, op2, "__le")
         if h then
           return not not h(op1, op2)
         else
           h = getbinhandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error("エラー")
           end
         end
       end
     end
     ```

  "le"メタメソッドが存在しない場合、Luaは"lt"メタメソッドを試み、`a <= b` を`not (b < a)`として扱います。他の比較演算子と同様、結果は常にブール値です。

- **"index"**: インデックス参照 `table[key]`。`key`がテーブルに存在しない場合のみメタメソッドが呼ばれます。（`table`がテーブルでない場合、どのキーも存在しないためメタメソッドは常に試行されます。）

     ```lua
     function gettable_event(table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         -- キーが存在すれば、未加工の値を返す
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error("エラー")
         end
       end
       if type(h) == "function" then
         return (h(table, key))  -- ハンドラを呼び出す
       else return h[key]        -- またはハンドラに対して操作を繰り返す
       end
     end
     ```

- **"newindex"**: インデックス代入 `table[key] = value`。`key`がテーブルに存在しない場合のみメタメソッドが呼ばれます。

     ```lua
     function settable_event(table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         -- キーが存在すれば、未加工の代入を行う
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error("エラー")
         end
       end
       if type(h) == "function" then
         h(table, key, value)   -- ハンドラを呼び出す
       else h[key] = value      -- またはハンドラに対して操作を繰り返す
       end
     end
     ```

- **"call"**: Luaが値を呼び出すときに使用されます。

     ```lua
     function function_event(func, ...)
       if type(func) == "function" then
         return func(...)   -- 基本の呼び出し
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else


           error("エラー")
         end
       end
     end
     ```

### 2.5 - ガベージコレクション

Luaは自動メモリ管理を行います。つまり、新しいオブジェクトのためにメモリを割り当てたり、不要になったオブジェクトのメモリを解放したりすることを気にする必要はありません。Luaはガベージコレクタを実行して、不要なオブジェクト（Luaからアクセスできなくなったオブジェクト）をすべて収集することでメモリを自動管理します。Luaが使用するすべてのメモリ（文字列、テーブル、ユーザデータ、関数、スレッド、内部構造など）は、自動管理の対象です。

Luaは増分マーク＆スイープ方式のガベージコレクタを実装しています。このガベージコレクションサイクルを制御するために、ガベージコレクタの「ポーズ」と「ステップ倍率」という2つの数値を使用します。どちらも単位はパーセントで表されます（例: 値100は内部的に1を意味します）。

ガベージコレクタのポーズは、新しいサイクルを開始する前にガベージコレクタが待機する時間を制御します。値が大きいほどガベージコレクタは控えめに動作します。100未満の値ではガベージコレクタが待機せずに新しいサイクルを開始します。値が200の場合、使用メモリが2倍になるまで待機してから新しいサイクルを開始します。

ガベージコレクタのステップ倍率は、メモリ割り当てに対するガベージコレクタの相対速度を制御します。値が大きいほどガベージコレクタは積極的に動作しますが、各増分ステップのサイズも大きくなります。100未満の値ではガベージコレクタが遅くなりすぎ、サイクルを完了できない可能性があります。デフォルトは200で、これはガベージコレクタがメモリ割り当ての「2倍」の速度で実行されることを意味します。

ステップ倍率を非常に大きな数値（プログラムで使用可能な最大バイト数の10%以上）に設定すると、ガベージコレクタはストップ・ザ・ワールド（全停止）コレクタのように動作します。さらにポーズを200に設定すると、ガベージコレクタは古いLuaバージョンのように動作し、Luaがメモリ使用量を2倍にするたびに完全なコレクションを実行します。

これらの数値は、C言語の`lua_gc`またはLuaの`collectgarbage`関数を使って変更できます。また、これらの関数を使用してガベージコレクタを直接制御することも可能です（例: 停止や再開など）。

Lua 5.2では実験的な機能として、コレクタの動作モードを増分型から世代別型に変更することができます。世代別ガベージコレクタは、大半のオブジェクトが生成後すぐに不要になると仮定し、新しい（最近生成された）オブジェクトだけを処理します。この動作によりガベージコレクタの使用時間が減少する可能性がありますが、メモリ使用量は増加する場合があります（古い不要なオブジェクトが蓄積される可能性があるためです）。この問題を軽減するため、世代別ガベージコレクタは定期的に完全なコレクションを実行します。この機能は実験的なものであることを忘れず、試してみることは可能ですが、その効果を確認してください。

#### 2.5.1 - ガベージコレクションのメタメソッド

テーブルや、C APIを使用したフルユーザデータ（§2.4参照）にガベージコレクションのメタメソッドを設定することができます。これらのメタメソッドは「ファイナライザ」とも呼ばれます。ファイナライザを使用すると、Luaのガベージコレクションと外部リソース管理（例: ファイル、ネットワークやデータベース接続の終了、自分で確保したメモリの解放など）を連携させることができます。

オブジェクト（テーブルまたはユーザデータ）をコレクション時にファイナライズ（終了処理）するためには、ファイナライズ用にマークする必要があります。ファイナライズ用にオブジェクトをマークするには、メタテーブルを設定し、そのメタテーブルに`"__gc"`というインデックスのフィールドを持たせます。なお、`__gc`フィールドがないメタテーブルを設定し、その後でそのフィールドをメタテーブルに追加した場合、オブジェクトはファイナライズ用にマークされません。しかし、一度オブジェクトがマークされると、そのメタテーブルの`__gc`フィールドは自由に変更できます。

マークされたオブジェクトがガベージになったとき、ガベージコレクタによってすぐに回収されるわけではありません。Luaはそのオブジェクトをリストに追加し、コレクション後にリスト内の各オブジェクトに対して以下のような関数を実行します：

     ```lua
     function gc_event (obj)
       local h = metatable(obj).__gc
       if type(h) == "function" then
         h(obj)
       end
     end
     ```

各ガベージコレクションサイクルの終了時に、ファイナライズが必要なオブジェクトのファイナライザが、サイクル内で回収された順に逆順で呼び出されます。つまり、プログラム内で最後にマークされたオブジェクトに関連するファイナライザが最初に呼び出されます。各ファイナライザの実行は、通常のコードの実行中の任意のポイントで行われることがあります。

収集されているオブジェクトはファイナライザで使用されるため、（およびファイナライザを通じてのみアクセス可能な他のオブジェクトも）一時的にLuaによって復活（リザレクション）されなければなりません。通常、この復活は一時的であり、次のガベージコレクションサイクルでオブジェクトメモリは解放されます。しかし、ファイナライザがオブジェクトをグローバルな場所（例: グローバル変数）に格納した場合は、オブジェクトが永続的に復活します。いずれの場合も、オブジェクトが完全にアクセスできなくなったときにのみメモリが解放され、ファイナライザが2回呼び出されることはありません。

状態を閉じるとき（`lua_close`参照）、Luaはファイナライズ対象にマークされたすべてのオブジェクトのファイナライザを、マークされた順序の逆順で呼び出します。この段階でファイナライザが新しいオブジェクトを収集対象にマークした場合、それらの新しいオブジェクトはファイナライズされません。

### 2.5.2 - 弱テーブル

弱テーブルとは、要素が弱参照であるテーブルのことです。弱参照はガベージコレクタによって無視されます。つまり、オブジェクトへの参照が弱参照のみの場合、ガベージコレクタはそのオブジェクトを回収します。

弱テーブルには、キーが弱参照のもの、値が弱参照のもの、または両方が弱参照のものがあります。キーが弱いテーブルではキーの回収が可能になりますが、値の回収は防止されます。一方、キーと値の両方が弱いテーブルでは、どちらも回収可能です。いずれの場合も、キーまたは値のいずれかが回収されると、そのペア全体がテーブルから削除されます。テーブルの弱さはメタテーブルの`__mode`フィールドで制御されます。`__mode`フィールドが文字`'k'`を含む文字列であれば、テーブルのキーは弱くなります。`__mode`が`'v'`を含む場合、テーブルの値は弱くなります。

キーが弱く値が強いテーブルは「エフェメロンテーブル」とも呼ばれます。エフェメロンテーブルでは、キーが到達可能な場合のみその値が到達可能と見なされます。特に、キーへの唯一の参照が値からの場合、そのペアは削除されます。

テーブルの弱さを変更しても、その効果が現れるのは次のコレクションサイクルからです。特に、弱さを強く変更した場合でも、変更が反映される前にLuaがそのテーブルからいくつかの項目を回収する可能性があります。

明示的な構築があるオブジェクトのみが弱テーブルから削除されます。数値や軽量C関数のような値はガベージコレクションの対象ではないため、弱テーブルから削除されません（ただし、関連する値が回収された場合は例外です）。文字列はガベージコレクションの対象ですが、明示的な構築がないため、弱テーブルからは削除されません。

復活したオブジェクト（ファイナライズ中のオブジェクトや、ファイナライズ中のオブジェクトを介してのみアクセス可能なオブジェクト）は、弱テーブルにおいて特別な挙動を示します。これらは、ファイナライザの実行前に弱値から削除されますが、弱キーからはファイナライザの実行後の次のコレクションサイクルまで削除されません。この動作により、ファイナライザが弱テーブルを通じてオブジェクトに関連するプロパティにアクセスできるようになります。

あるコレクションサイクルで復活したオブジェクトの中に弱テーブルが含まれている場合、そのテーブルのクリアが次のサイクルまで適切に行われないことがあります。

### 2.6 - コルーチン

Luaはコルーチン、または協調的マルチスレッドをサポートしています。Luaにおけるコルーチンは、独立した実行スレッドを表します。ただし、マルチスレッドシステムのスレッドとは異なり、コルーチンは`yield`関数を明示的に呼び出すことでのみ実行を中断します。

コルーチンは`coroutine.create`を呼び出して作成します。この関数の唯一の引数は、コルーチンのメイン関数となる関数です。`create`関数は新しいコルーチンを作成し、そのハンドル（スレッド型のオブジェクト）を返すだけで、コルーチンを開始するわけではありません。

コルーチンを実行するには、`coroutine.resume`を呼び出します。最初に`coroutine.resume`を呼び出す際には、最初の引数に`coroutine.create`で返されたスレッドを渡します。すると、コルーチンのメイン関数の最初の行から実行が始まります。`coroutine.resume`に渡された追加の引数は、コルーチンのメイン関数に引き継がれます。コルーチンが実行を開始すると、終了または中断するまで動作を続けます。

コルーチンが実行を終了するのは、以下の2通りです：通常の終了（メイン関数が戻り値を返すか、最後の命令を実行した後）または保護されていないエラーの発生による異常終了です。通常終了の場合、`coroutine.resume`は`true`と、コルーチンのメイン関数から返された任意の値を返します。エラーが発生した場合は、`coroutine.resume`は`false`とエラーメッセージを返します。

コルーチンは`coroutine.yield`を呼び出すことで実行を中断します。コルーチンが中断すると、対応する`coroutine.resume`は即座に戻り、中断がネストされた関数呼び出しの中で（つまり、メイン関数ではなく、メイン関数から直接または間接的に呼び出された関数内で）発生していても、その場所で戻ります。`yield`の場合、`coroutine.resume`も`true`を返し、さらに`coroutine.yield`に渡された任意の値も返されます。次に同じコルーチンを再開すると、中断した場所から続行され、`coroutine.yield`に戻り、`coroutine.resume`に渡された追加の引数が返されます。

`coroutine.create`と同様に、`coroutine.wrap`関数もコルーチンを作成しますが、コルーチン自体を返す代わりに、それを再開する関数を返します。この関数に渡された任意の引数は、追加の引数として`coroutine.resume`に渡されます。`coroutine.wrap`は`coroutine.resume`の返り値をすべて返しますが、最初のブール型のエラーフラグは除きます。`coroutine.resume`とは異なり、`coroutine.wrap`はエラーをキャッチしないため、エラーは呼び出し元に伝播されます。

以下は、コルーチンがどのように動作するかを示す例です：

```lua
function foo (a)
  print("foo", a)
  return coroutine.yield(2 * a)
end

co = coroutine.create(function (a, b)
      print("co-body", a, b)
      local r = foo(a + 1)
      print("co-body", r)
      local r, s = coroutine.yield(a + b, a - b)
      print("co-body", r, s)
      return b, "end"
end)

print("main", coroutine.resume(co, 1, 10))
print("main", coroutine.resume(co, "r"))
print("main", coroutine.resume(co, "x", "y"))
print("main", coroutine.resume(co, "x", "y"))
```

上記のコードを実行すると、以下の出力が得られます：

```
co-body 1       10
foo     2
main    true    4
co-body r
main    true    11      -9
co-body x       y
main    true    10      end
main    false   cannot resume dead coroutine
```

また、コルーチンはC APIを通じて作成および操作することも可能です。具体的には、`lua_newthread`、`lua_resume`、および`lua_yield`関数を使用します。

## 3 – 言語

このセクションでは、Luaの字句（lexis）、構文（syntax）、および意味（semantics）について説明します。言い換えると、このセクションでは有効なトークンがどれか、それらがどのように組み合わせられるか、およびその組み合わせが何を意味するかについて解説します。

言語の構造は、一般的な拡張BNF記法を使って説明されます。この記法では、`{a}`は「0回以上のa」、`[a]`は「任意のa（ある場合とない場合の両方が許容される）」を意味します。非終端記号は`non-terminal`のように、キーワードは`kword`のように、その他の終端記号は`'='`のように表示されます。Luaの完全な構文については、このマニュアルの末尾にある§9で確認できます。

### 3.1 – 字句規則

Luaは自由形式の言語で、スペース（改行も含む）やコメントは字句要素（トークン）間の区切りとして使用される場合を除き無視されます。

Luaの名前（識別子とも呼ばれます）は、文字、数字、およびアンダースコアの組み合わせで構成されますが、最初の文字に数字は使用できません。識別子は変数、テーブルのフィールド、ラベルの名前を定義するために使用されます。

以下のキーワードは予約されており、名前として使用することはできません。

```
and       break     do        else      elseif    end
false     for       function  goto      if        in
local     nil       not       or        repeat    return
then      true      until     while
```

Luaは大文字と小文字を区別します。たとえば、`and`は予約語ですが、`And`や`AND`は別の有効な名前として認識されます。また、慣例として、アンダースコアと大文字で始まる名前（例：`_VERSION`）はLuaで使用される変数のために予約されています。

以下の文字列はその他のトークンを表します。

```
+     -     *     /     %     ^     #
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]     ::
;     :     ,     .     ..    ...
```

リテラル文字列はシングルクォートまたはダブルクォートで囲むことができ、次のC言語風のエスケープシーケンスを含むことができます：
- `\a`（ベル）
- `\b`（バックスペース）
- `\f`（改ページ）
- `\n`（改行）
- `\r`（キャリッジリターン）
- `\t`（水平タブ）
- `\v`（垂直タブ）
- `\\`（バックスラッシュ）
- `\"`（ダブルクォート）
- `\'`（シングルクォート）

バックスラッシュの後に改行を置くと、文字列内に改行が挿入されます。エスケープシーケンス `\z` は後に続く空白文字（改行を含む）をスキップします。これは、長いリテラル文字列を複数行に分けてインデントする際、改行やスペースを含めずに見やすくするために便利です。

リテラル文字列内のバイトを数値で指定することも可能です。16進数の2桁を使ったエスケープシーケンス `\xXX`（例：`\x41`はASCIIコードの'A'）や、最大3桁の10進数を使ったエスケープシーケンス `\ddd`（例：`\065`も'A'）で指定します。ただし、10進エスケープの後にさらに数字が続く場合は、必ず3桁で指定する必要があります。Luaの文字列は埋め込みゼロ（`\0`）を含む任意の8ビット値を含むことができます。

リテラル文字列は、長い形式で長い角括弧を使用して定義することもできます。レベルnの開き長角括弧は、開き角括弧`[`の後にn個の等号`=`を置き、さらにもう一つの開き角括弧`[`で囲む形式です。レベル0の開き長角括弧は`[[`と書き、レベル1は`[=[`、レベル4なら`[====[`のように書きます。同様に閉じる角括弧も指定され、例えばレベル4では`]====]`となります。長いリテラル文字列は、任意のレベルの開き長角括弧で始まり、同じレベルの閉じ長角括弧で終わります。この形式のリテラルは複数行にわたり、エスケープシーケンスを解釈せず、異なるレベルの長角括弧を無視します。行末の改行コード（キャリッジリターンや改行、もしくはそれらの組み合わせ）は単純な改行に変換されます。

リテラル文字列内のバイトは、前述のルールに該当しない限り、そのままの値として扱われます。ただし、Luaはファイルをテキストモードで開いて解析するため、システムのファイル関数が一部の制御文字に問題を起こす可能性があります。そのため、テキスト以外のデータを扱う場合は、引用符で囲んだリテラルに明示的なエスケープシーケンスを使用する方が安全です。

開き長角括弧の直後に改行が続く場合、その改行は文字列に含まれません。以下に示す5つのリテラル文字列は、ASCIIを使用するシステム（例：`'a'`は97、改行は10、`'1'`は49としてコード化されている）において、同じ内容を表します。

```lua
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]
```

数値定数は、小数部や10進数の指数部（`e`または`E`で示される）を含めることができます。Luaでは16進定数も受け付け、`0x`または`0X`で始まります。16進定数には小数部および2進指数部（`p`または`P`で示される）も含められます。以下は有効な数値定数の例です。

```lua
3     3.0     3.1416     314.16e-2     0.31416E1
0xff  0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
```

コメントは、文字列外で`--`から始まります。`--`の直後に開き長角括弧がなければ、そのコメントは短いコメントとして行の終わりまで続きます。そうでなければ、それは長いコメントとなり、対応する閉じ長角括弧が現れるまで続きます。長いコメントはコードの一時的な無効化によく使われます。

### 3.2 – 変数

変数は値を格納する場所です。Luaには、グローバル変数、ローカル変数、およびテーブルフィールドの3種類の変数があります。

単一の名前は、グローバル変数やローカル変数（または関数の仮引数、特定のローカル変数）を表すことができます。

```lua
var ::= Name
```

`Name`は§3.1で定義されている識別子を指します。変数名は特に指定しない限りグローバル変数とみなされます（§3.3.7を参照）。ローカル変数はレキシカルスコープを持ち、そのスコープ内で定義された関数から自由にアクセスできます（§3.5参照）。

変数に最初に値が代入される前の初期値は`nil`です。

テーブルのインデックス付けには角括弧を使用します。

```lua
var ::= prefixexp ‘[’ exp ‘]’
```

テーブルフィールドへのアクセスの意味はメタテーブルを使って変更できます。インデックス付き変数`t[i]`へのアクセスは、`gettable_event(t, i)`の呼び出しと同等です（`gettable_event`関数はLuaで定義や呼び出しができませんが、説明のために用いています。§2.4を参照）。

構文`var.Name`は単に`var["Name"]`の構文糖（書き方の簡略化）です。

```lua
var ::= prefixexp ‘.’ Name
```

グローバル変数`x`へのアクセスは`_ENV.x`と同等です。チャンクのコンパイル方法により、`_ENV`はグローバル名にはなりません（§2.2を参照）。

### 3.3 – 文（Statements）

Luaは、PascalやCに似た一般的な文セットをサポートしています。このセットには、代入、制御構造、関数呼び出し、変数宣言が含まれます。

#### 3.3.1 – ブロック（Blocks）

ブロックは一連の文のリストで、これらは順番に実行されます。

```lua
block ::= {stat}
```

Luaには空の文があり、これにより文をセミコロンで区切ったり、ブロックをセミコロンで始めたり、セミコロンを2つ連続して書くことができます。

```lua
stat ::= ‘;’
```

関数呼び出しや代入は開き括弧から始めることができます。このため、Luaの文法には曖昧さが生じる場合があります。次のコードを例にとります。

```lua
a = b + c
(print or io.write)('done')
```

このコードは、次のように解釈できます。

```lua
a = b + c(print or io.write)('done')
```

または

```lua
a = b + c; (print or io.write)('done')
```

現在のパーサーは、開き括弧を関数呼び出しの引数の始まりと解釈するため、常に最初のように解釈されます。この曖昧さを避けるために、括弧で始まる文の前には常にセミコロンを置くのが良い習慣です。

```lua
;(print or io.write)('done')
```

ブロックは、単一の文として明示的に区切ることもできます。

```lua
stat ::= do block end
```

明示的なブロックは、変数宣言のスコープを制御するのに役立ちます。また、別のブロックの途中に`return`文を挿入する場合にも使用されます（§3.3.4を参照）。

#### 3.3.2 – チャンク（Chunks）

Luaのコンパイル単位は「チャンク」と呼ばれます。文法的には、チャンクは単なるブロックです。

```lua
chunk ::= block
```

Luaはチャンクを、可変引数を持つ無名関数の本体として扱います（§3.4.10を参照）。そのため、チャンクはローカル変数を定義し、引数を受け取り、値を返すことができます。この無名関数は、外部ローカル変数である`_ENV`のスコープでコンパイルされます（§2.2を参照）。結果として生成される関数には、たとえ使用しなくても`_ENV`が唯一のアップバリューとして含まれます。

チャンクは、ファイル内またはホストプログラム内の文字列として保存できます。チャンクを実行するには、Luaがまず仮想マシン用の命令に事前コンパイルし、次にそのコンパイルされたコードを仮想マシン用のインタープリタで実行します。

チャンクはバイナリ形式に事前コンパイルすることもできます。詳細は`luac`プログラムを参照してください。ソース形式とコンパイル済み形式のプログラムは相互に交換可能であり、Luaはファイルの種類を自動的に検出し、それに応じた動作を行います。

#### 3.3.3 – 代入（Assignment）

Luaでは複数の代入が可能です。そのため、代入の構文では、左側に変数リスト、右側に式のリストを定義します。両リストの要素はコンマで区切ります。

```lua
stat ::= varlist ‘=’ explist
varlist ::= var {‘,’ var}
explist ::= exp {‘,’ exp}
```

式については§3.4で説明します。

代入の前に、値のリストは変数リストの長さに合わせて調整されます。必要な変数より多くの値がある場合、余剰の値は破棄されます。必要な値が不足している場合、リストは必要なだけ`nil`で拡張されます。式リストが関数呼び出しで終わっている場合、その呼び出しによって返されるすべての値が値リストに含まれた後、リストの調整が行われます（関数呼び出しが括弧で囲まれている場合を除きます。詳細は§3.4を参照）。

代入文は、まずすべての式を評価し、その後で代入が実行されます。したがって、次のコードでは

```lua
i = 3
i, a[i] = i+1, 20
```

`a[3]`が20に設定され、`a[4]`には影響がありません。これは、`a[i]`内の`i`が評価される（3に評価）前に`4`が代入されるためです。同様に、次のコードは

```lua
x, y = y, x
```

`x`と`y`の値を入れ替え、次のコード

```lua
x, y, z = y, z, x
```

は`x`、`y`、`z`の値を循環的に入れ替えます。

グローバル変数やテーブルフィールドへの代入の意味は、メタテーブルを使用して変更できます。インデックス付き変数`t[i] = val`への代入は、`settable_event(t, i, val)`の呼び出しと同等です（`settable_event`関数はLuaで定義や呼び出しができませんが、説明のために使用しています。§2.4を参照）。

グローバル変数`x = val`への代入は、`_ENV.x = val`の代入と同等です（§2.2を参照）。

#### 3.3.4 – 制御構造

`if`、`while`、`repeat`の制御構造は、通常の意味とおなじみの構文を持っています。

```lua
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
```

Luaには`for`文もあり、2種類の形式があります（§3.3.5を参照）。

制御構造の条件式は任意の値を返すことができます。`false`と`nil`は「偽」と見なされます。それ以外のすべての値は「真」と見なされます（特に数値0や空文字列も「真」として扱われます）。

`repeat–until`ループでは、内部ブロックは`until`キーワードで終了せず、条件の後まで続きます。このため、条件はループブロック内で宣言されたローカル変数を参照できます。

`goto`文はプログラムの制御をラベルへ移します。構文上の理由から、Luaのラベルも文として扱われます。

```lua
stat ::= goto Name
stat ::= label
label ::= ‘::’ Name ‘::’
```

ラベルは、そのブロック内で定義されている間は全体で可視です。ただし、同じ名前のラベルが定義されているネストされたブロックや、ネストされた関数内では可視ではありません。`goto`はローカル変数のスコープに入らない限り、可視なラベルにジャンプできます。

ラベルや空の文は何の動作も行わないため、「無効文」と呼ばれます。

`break`文は、`while`、`repeat`、または`for`ループの実行を終了し、ループの後の次の文に進みます。

```lua
stat ::= break
```

`break`は最も内側のループを終了させます。

`return`文は、関数またはチャンク（見かけ上の関数）から値を返すために使用されます。関数は複数の値を返すことができるため、`return`文の構文は次のようになります。

```lua
stat ::= return [explist] [‘;’]
```

`return`文はブロックの最後の文としてのみ書くことができます。ブロックの途中で値を返す必要がある場合は、`do return end`のように明示的な内部ブロックを使うことができます。これにより、`return`がその（内部）ブロックの最後の文となります。

#### 3.3.5 – For文

`for`文には数値形式と一般形式の2つの形式があります。

数値形式の`for`ループは、制御変数が算術的な進行で進む間、ブロックを繰り返します。構文は次の通りです。

```lua
stat ::= for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end
```

ブロックは、`name`が最初の`exp`の値から始まり、第3の`exp`のステップごとに進み、第2の`exp`を超えるまで繰り返されます。より正確には、次のような`for`文

```lua
for v = e1, e2, e3 do block end
```

は以下のコードと等価です。

```lua
do
  local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
  if not (var and limit and step) then error() end
  while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do
    local v = var
    block
    var = var + step
  end
end
```

注意点は次の通りです。

- 制御式の3つの式は、ループの開始前に一度だけ評価されます。すべての式は数値である必要があります。
- `var`、`limit`、`step`は不可視の変数です。ここでの名前は説明用に使われています。
- 第3の式（`step`）が省略されると、ステップは1が使用されます。
- `break`を使って`for`ループを終了できます。
- ループ変数`v`はループ内でローカルです。`for`が終了するか中断された後はその値を使用できません。値が必要な場合は、ループを終了する前に他の変数に代入してください。

一般形式の`for`文は、イテレータと呼ばれる関数で動作します。各反復で、イテレータ関数が呼び出され、新しい値が生成され、`nil`が返された時に停止します。一般形式の`for`ループの構文は次の通りです。

```lua
stat ::= for namelist in explist do block end
namelist ::= Name {‘,’ Name}
```

次のような`for`文

```lua
for var_1, ···, var_n in explist do block end
```

は以下のコードと等価です。

```lua
do
  local f, s, var = explist
  while true do
    local var_1, ···, var_n = f(s, var)
    if var_1 == nil then break end
    var = var_1
    block
  end
end
```

注意点は次の通りです。

- `explist`は一度だけ評価され、イテレータ関数、状態、および最初のイテレータ変数の初期値が結果として得られます。
- `f`、`s`、`var`は不可視の変数です。ここでの名前は説明用に使われています。
- `break`を使って`for`ループを終了できます。
- ループ変数`var_i`はループ内でローカルです。`for`が終了する後はその値を使用できません。値が必要な場合は、ループを終了する前に他の変数に代入してください。

#### 3.3.6 – 文としての関数呼び出し

副作用が生じる可能性を考慮して、関数呼び出しは文として実行することができます。

```lua
stat ::= functioncall
```

この場合、すべての戻り値は破棄されます。関数呼び出しについては§3.4.9で説明されています。

#### 3.3.7 – ローカル変数の宣言

ローカル変数は、ブロック内の任意の場所で宣言できます。宣言には初期値の代入を含めることができます。

```lua
stat ::= local namelist [‘=’ explist]
```

初期代入がある場合、その動作は複数代入と同じです（§3.3.3を参照）。ない場合、すべての変数は`nil`で初期化されます。

チャンクもブロックであるため（§3.3.2を参照）、ローカル変数は明示的なブロック外のチャンク内でも宣言できます。

ローカル変数の可視性ルールについては§3.5で説明されています。

### 3.4 – 式（Expressions）

Luaの基本的な式は次の通りです。

```lua
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Number
exp ::= String
exp ::= functiondef
exp ::= tableconstructor
exp ::= ‘...’
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | ‘(’ exp ‘)’
```

数値とリテラル文字列は§3.1で説明され、変数は§3.2で、関数定義は§3.4.10で、関数呼び出しは§3.4.9で、テーブルコンストラクタは§3.4.8で説明されています。可変引数式（`...`で示される）は、可変引数を持つ関数内で直接使用する場合にのみ有効です（§3.4.10を参照）。

二項演算子には、算術演算子（§3.4.1参照）、関係演算子（§3.4.3参照）、論理演算子（§3.4.4参照）、および連結演算子（§3.4.5参照）が含まれます。単項演算子には、単項マイナス（§3.4.1参照）、単項否定（`not`、§3.4.4参照）、および単項長さ演算子（`#`、§3.4.6参照）が含まれます。

関数呼び出しと可変引数式は、複数の値を返す場合があります。関数呼び出しが文として使用される場合（§3.3.6を参照）、戻り値のリストは0要素に調整され、すべての戻り値が破棄されます。式が式リストの最後の要素（または唯一の要素）として使用される場合、調整は行われません（式が括弧で囲まれている場合を除く）。それ以外のすべての状況で、Luaは戻り値のリストを1つの要素に調整し、最初の値以外を破棄するか、値がない場合は`nil`を追加します。

以下にいくつかの例を示します。

```lua
f()                -- 0個の結果に調整
g(f(), x)          -- f()は1個の結果に調整される
g(x, f())          -- gはxとf()のすべての結果を取得
a, b, c = f(), x   -- f()は1個の結果に調整され、cにはnilが代入される
a, b = ...         -- aには最初の可変引数、bには2番目が入る（可変引数がなければaやbにはnilが入る）

a, b, c = x, f()   -- f()は2個の結果に調整される
a, b, c = f()      -- f()は3個の結果に調整される
return f()         -- f()のすべての結果を返す
return ...         -- 受け取った可変引数をすべて返す
return x, y, f()   -- x, yとf()のすべての結果を返す
{f()}              -- f()のすべての結果を含むリストを作成
{...}              -- すべての可変引数を含むリストを作成
{f(), nil}         -- f()は1個の結果に調整される
```

括弧で囲まれた任意の式は、常に1つの値のみを返します。したがって、`(f(x, y, z))`は`f`が複数の値を返す場合でも常に単一の値です。（`(f(x, y, z))`の値は、`f`が返す最初の値、または`f`が何も返さない場合は`nil`です。）

#### 3.4.1 – 算術演算子

Luaは一般的な算術演算子をサポートしています。二項演算子の`+`（加算）、`-`（減算）、`*`（乗算）、`/`（除算）、`%`（剰余）、`^`（べき乗）と、単項演算子の`-`（数学的な否定）です。オペランドが数値または数値に変換できる文字列（§3.4.2を参照）であれば、すべての演算子は通常の意味で動作します。べき乗は任意の指数に対応し、例えば`x^(-0.5)`は`x`の平方根の逆数を計算します。剰余演算は次のように定義されます。

```lua
a % b == a - math.floor(a/b)*b
```

これは、商をマイナス無限大に向かって丸めた除算の余りに相当します。

#### 3.4.2 – 型変換

Luaは、実行時に文字列と数値の間の自動変換を提供します。文字列に対して算術演算が適用される場合、その文字列はLuaの字句解析器の規則に従って数値に変換されます（文字列には前後のスペースや符号が含まれていても構いません）。逆に、文字列が必要な箇所で数値が使われた場合、数値は適切な形式で文字列に変換されます。数値の文字列への変換を完全に制御するには、文字列ライブラリの`format`関数を使用してください（`string.format`を参照）。

#### 3.4.3 – 関係演算子

Luaの関係演算子は以下の通りです。

```lua
==    ~=    <     >     <=    >=
```

これらの演算子は常に`false`または`true`を返します。

等価演算子`==`は、まずオペランドの型を比較します。型が異なる場合、結果は`false`になります。型が同じであれば、オペランドの値を比較します。数値と文字列は通常通り比較され、テーブル、ユーザデータ、スレッドは参照によって比較されます。つまり、2つのオブジェクトが同じオブジェクトである場合にのみ等しいと見なされます。新しいオブジェクト（テーブル、ユーザデータ、スレッド）を作成するたびに、それは既存のオブジェクトとは異なります。同じ参照を持つクロージャは常に等しいと見なされ、異なる動作や定義を持つクロージャは常に異なると見なされます。

テーブルやユーザデータの比較方法は、`"eq"`メタメソッドを使用して変更できます（§2.4を参照）。

§3.4.2の変換ルールは等価比較には適用されません。したがって、`"0" == 0`は`false`を返し、`t[0]`と`t["0"]`はテーブル内の異なるエントリを示します。

演算子`~=`は等価演算子`==`の否定です。

順序演算子は次のように動作します。両方の引数が数値であれば、数値として比較されます。両方の引数が文字列であれば、現在のロケールに従って値を比較します。それ以外の場合、Luaは`"lt"`または`"le"`メタメソッドを呼び出そうとします（§2.4を参照）。比較`a > b`は`b < a`に、`a >= b`は`b <= a`に変換されます。

#### 3.4.4 – 論理演算子

Luaの論理演算子には`and`、`or`、`not`があります。制御構造と同様（§3.3.4参照）、論理演算子は`false`と`nil`を「偽」とし、それ以外を「真」と見なします。

否定演算子`not`は常に`false`または`true`を返します。論理積演算子`and`は、最初の引数が`false`または`nil`の場合、その引数を返し、それ以外の場合は2番目の引数を返します。論理和演算子`or`は、最初の引数が`nil`および`false`以外であればその引数を返し、それ以外の場合は2番目の引数を返します。`and`と`or`は短絡評価を行い、2番目のオペランドは必要な場合にのみ評価されます。いくつかの例を以下に示します。

```lua
10 or 20            --> 10
10 or error()       --> 10
nil or "a"          --> "a"
nil and 10          --> nil
false and error()   --> false
false and nil       --> false
false or nil        --> nil
10 and 20           --> 20
```

（このマニュアルでは、`-->`は前の式の結果を示しています。）

#### 3.4.5 – 連結

Luaの文字列連結演算子は2つのドット（`..`）で示されます。両方のオペランドが文字列または数値であれば、§3.4.2で説明されている規則に従って文字列に変換されます。それ以外の場合、`__concat`メタメソッドが呼び出されます（§2.4を参照）。

#### 3.4.6 – 長さ演算子

長さ演算子は単項の接頭辞演算子`#`で表されます。文字列の長さは、そのバイト数です（つまり、各文字が1バイトの場合の通常の文字列の長さの意味になります）。

文字列以外の値に対して長さ演算子の動作を変更するには、`__len`メタメソッドを使用できます（§2.4を参照）。

`__len`メタメソッドが指定されていない場合、テーブル`t`の長さは、テーブルが「シーケンス」（正の数値キーの集合が{1..n}と一致する非負整数`n`が存在する）である場合にのみ定義されます。この場合、`n`がそのテーブルの長さです。例えば、以下のようなテーブル

```lua
{10, 20, nil, 40}
```

はキー4を持ちますが、キー3がないためシーケンスではありません（つまり、このテーブルの正の数値キーの集合が{1..n}と一致するような`n`は存在しません）。ただし、数値でないキーはテーブルがシーケンスであるかどうかには影響を与えません。

#### 3.4.7 – 優先順位

Luaにおける演算子の優先順位は次の表に示されており、下から上に向かって優先順位が高くなります。

```
or
and
<     >     <=    >=    ~=    ==
..
+     -
*     /     %
not   #     - (単項)
^
```

通常、式の優先順位を変更するには括弧を使用します。連結演算子（`..`）およびべき乗演算子（`^`）は右結合です。それ以外の二項演算子は左結合です。

#### 3.4.8 – テーブルコンストラクタ

テーブルコンストラクタはテーブルを作成する式です。コンストラクタが評価されるたびに新しいテーブルが作成されます。コンストラクタを使用して空のテーブルを作成したり、いくつかのフィールドを初期化したテーブルを作成したりできます。コンストラクタの一般的な構文は次の通りです。

```lua
tableconstructor ::= ‘{’ [fieldlist] ‘}’
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= ‘[’ exp ‘]’ ‘=’ exp | Name ‘=’ exp | exp
fieldsep ::= ‘,’ | ‘;’
```

`[exp1] = exp2`形式の各フィールドは、新しいテーブルにキー`exp1`と値`exp2`を持つエントリを追加します。`name = exp`形式のフィールドは`["name"] = exp`と等価です。最後に、`exp`形式のフィールドは、`i`が1から始まる連続する数値インデックスで`[i] = exp`と等価です。その他の形式のフィールドはこのカウントに影響しません。例えば、

```lua
a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
```

は以下のコードと等価です。

```lua
do
  local t = {}
  t[f(1)] = g
  t[1] = "x"         -- 1番目のexp
  t[2] = "y"         -- 2番目のexp
  t.x = 1            -- t["x"] = 1
  t[3] = f(x)        -- 3番目のexp
  t[30] = 23
  t[4] = 45          -- 4番目のexp
  a = t
end
```

リストの最後のフィールドが`exp`形式で、式が関数呼び出しや可変引数式である場合、その式が返すすべての値がリストに連続して追加されます（§3.4.9を参照）。

フィールドリストには、機械生成コードの便宜のため、末尾の区切り記号を省略可能にすることができます。

#### 3.4.9 – 関数呼び出し

Luaにおける関数呼び出しの構文は次の通りです。

```lua
functioncall ::= prefixexp args
```

関数呼び出しでは、まず`prefixexp`と`args`が評価されます。`prefixexp`の値が関数型であれば、その関数が指定された引数で呼び出されます。そうでない場合は、`prefixexp`の`"call"`メタメソッドが呼び出され、最初のパラメータとして`prefixexp`の値が渡され、続いて元の呼び出し引数が渡されます（§2.4を参照）。

次の形式

```lua
functioncall ::= prefixexp ‘:’ Name args
```

は「メソッド」を呼び出すために使用されます。`v:name(args)`という呼び出しは`v.name(v, args)`の構文糖にすぎませんが、`v`は一度だけ評価されます。

引数の構文は以下の通りです。

```lua
args ::= ‘(’ [explist] ‘)’
args ::= tableconstructor
args ::= String
```

すべての引数式は呼び出し前に評価されます。`f{fields}`形式の呼び出しは`f({fields})`の構文糖であり、引数リストが1つの新しいテーブルになります。同様に、`f'string'`（または`f"string"`や`f[[string]]`）形式の呼び出しは`f('string')`の構文糖で、引数リストは1つのリテラル文字列になります。

`return functioncall`形式の呼び出しは「末尾呼び出し」と呼ばれます。Luaは適切な末尾呼び出し（または適切な末尾再帰）を実装しています。末尾呼び出しでは、呼び出される関数が呼び出し元の関数のスタックエントリを再利用するため、プログラムで実行できる末尾呼び出しのネスト数に制限はありません。ただし、末尾呼び出しは呼び出し元のデバッグ情報を消去します。末尾呼び出しは特定の構文でのみ行われ、`return`が1つの関数呼び出しだけを引数として持つ場合に、呼び出し元の関数が呼び出される関数の戻り値をそのまま返します。したがって、以下の例は末尾呼び出しにはなりません。

```lua
return (f(x))        -- 結果は1つに調整される
return 2 * f(x)
return x, f(x)       -- 追加の結果がある
f(x); return         -- 結果が破棄される
return x or f(x)     -- 結果は1つに調整される
```

#### 3.4.10 – 関数定義

関数定義の構文は次の通りです。

```lua
functiondef ::= function funcbody
funcbody ::= ‘(’ [parlist] ‘)’ block end
```

関数定義を簡略化する構文糖は以下の通りです。

```lua
stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname ::= Name {‘.’ Name} [‘:’ Name]
```

次の文

```lua
function f () body end
```

は、以下のように変換されます。

```lua
f = function () body end
```

また、次の文

```lua
function t.a.b.c.f () body end
```

は、以下のように変換されます。

```lua
t.a.b.c.f = function () body end
```

さらに、次の文

```lua
local function f () body end
```

は以下に変換されますが、

```lua
local f; f = function () body end
```

次のようには変換されません。

```lua
local f = function () body end
```

（これは、関数本体が`f`への参照を含む場合にのみ違いが生じます。）

関数定義は実行可能な式で、その値は`function`型を持ちます。Luaがチャンクを事前コンパイルすると、その中のすべての関数本体も事前コンパイルされます。そして、Luaが関数定義を実行するたびに、関数がインスタンス化（またはクローズ）されます。この関数インスタンス（クロージャ）が式の最終的な値となります。

パラメータは、引数の値で初期化されるローカル変数として機能します。

```lua
parlist ::= namelist [‘,’ ‘...’] | ‘...’
```

関数が呼び出されると、引数リストはパラメータリストの長さに合わせて調整されます。ただし、パラメータリストの末尾に3つのドット（`...`）がある可変引数関数の場合、引数リストの調整は行われません。その代わりに、すべての追加の引数が可変引数式（`...`で表されます）を通じて関数に渡されます。この式の値は、追加の引数すべてを含むリストとなり、複数の戻り値を持つ関数と似ています。可変引数式が他の式内や式リストの途中で使用される場合、その戻り値リストは1つの要素に調整されます。式リストの最後の要素として使用される場合は、調整は行われません（ただし、その最後の式が括弧で囲まれている場合を除きます）。

例として、以下の定義を考えます。

```lua
function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end
```

このとき、引数とパラメータおよび可変引数式への対応は以下のようになります。

```lua
CALL            PARAMETERS
     
f(3)             a=3, b=nil
f(3, 4)          a=3, b=4
f(3, 4, 5)       a=3, b=4
f(r(), 10)       a=1, b=10
f(r())           a=1, b=2
     
g(3)             a=3, b=nil, ... -->  (なし)
g(3, 4)          a=3, b=4,   ... -->  (なし)
g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8
g(5, r())        a=5, b=1,   ... -->  2  3
```

戻り値は`return`文を使用して返されます（§3.3.4参照）。`return`文に遭遇しないまま関数の終わりに達すると、関数は戻り値なしで終了します。

システム依存で、関数が返すことのできる値の数には制限があります。この制限は1000以上であることが保証されています。

コロン構文はメソッド（暗黙的に追加のパラメータ`self`を持つ関数）を定義するために使用されます。したがって、次の文

```lua
function t.a.b.c:f (params) body end
```

は、以下の構文糖として扱われます。

```lua
t.a.b.c.f = function (self, params) body end
```

### 3.5 – 可視性ルール

Luaは字句スコープを持つ言語です。ローカル変数のスコープは、その宣言の後の最初の文から始まり、その宣言を含む最も内側のブロックの最後の有効な（空でない）文まで続きます。次の例を見てみましょう。

```lua
x = 10                -- グローバル変数
do                    -- 新しいブロック
  local x = x         -- 新しい'x'、値は10
  print(x)            --> 10
  x = x+1
  do                  -- 別のブロック
    local x = x+1     -- 別の'x'
    print(x)          --> 12
  end
  print(x)            --> 11
end
print(x)              --> 10  (グローバルの'x')
```

この例では、`local x = x`のような宣言の場合、宣言されている新しい`x`はまだスコープ内にないため、2番目の`x`は外側の変数を参照しています。

字句スコープの規則により、ローカル変数はそのスコープ内で定義された関数から自由にアクセスできます。内部関数で使用されるローカル変数は、内部関数内では「アップバリュー」または「外部ローカル変数」と呼ばれます。

また、ローカル文が実行されるたびに新しいローカル変数が定義される点にも注意が必要です。以下の例を見てみましょう。

```lua
a = {}
local x = 20
for i=1,10 do
  local y = 0
  a[i] = function () y=y+1; return x+y end
end
```

このループは10個のクロージャ（つまり無名関数の10個のインスタンス）を作成します。これらのクロージャはそれぞれ異なる`y`変数を使用し、すべてが同じ`x`変数を共有しています。

## 4 – アプリケーションプログラムインターフェース（API）

このセクションでは、LuaのC API、つまりLuaとの通信に使用できるホストプログラム向けのC関数セットについて説明します。すべてのAPI関数および関連する型や定数は、ヘッダーファイル`lua.h`に宣言されています。

「関数」という用語を使用していますが、API内の機能はマクロとして提供される場合もあります。特に明記されていない限り、これらのマクロは、引数を一度だけ使用します（最初の引数は常にLuaの状態を指します）。したがって、隠れた副作用を生成しません。

多くのCライブラリと同様に、Lua API関数は引数の有効性や整合性をチェックしません。ただし、Luaを`LUA_USE_APICHECK`マクロを定義してコンパイルすることで、この動作を変更することができます。

### 4.1 – スタック

Luaは、Cとの間で値をやり取りするために仮想スタックを使用します。このスタックの各要素は、Luaの値（`nil`、数値、文字列など）を表します。

LuaがCを呼び出すたびに、呼び出された関数は新しいスタックを受け取ります。このスタックは、以前のスタックや依然としてアクティブなC関数のスタックとは独立しています。このスタックには最初にC関数への引数が含まれており、C関数が結果をプッシュして呼び出し元に返す場所でもあります（`lua_CFunction`を参照）。

便宜上、APIの多くのクエリ操作では厳密なスタック規律に従う必要はありません。代わりに、スタック内の任意の要素にインデックスを使って参照できます。正のインデックスは絶対的なスタック位置を表し（1から始まります）、負のインデックスはスタックのトップからの相対的なオフセットを表します。具体的には、スタックに`n`個の要素がある場合、インデックス1は最初の要素（最初にプッシュされた要素）を、インデックス`n`は最後の要素を表します。また、インデックス`-1`も最後の要素（つまりトップの要素）を、インデックス`-n`は最初の要素を表します。

### 4.2 – スタックサイズ

Lua APIと対話する際には、一貫性を保つ責任がユーザーにあります。特に、スタックのオーバーフローを制御する責任があります。新しい要素をプッシュする際には、`lua_checkstack`関数を使ってスタックに追加のスロットがあることを確認できます。

LuaがCを呼び出すたびに、スタックには少なくとも`LUA_MINSTACK`の追加スロットが確保されます。`LUA_MINSTACK`は20として定義されており、通常、コードにスタックへの要素のプッシュを伴うループがない限り、スタックのスペースについて心配する必要はありません。

結果の数が固定されていない状態でLua関数を呼び出すとき（`lua_call`を参照）、Luaはすべての結果に対してスタックサイズが十分であることを保証しますが、追加のスペースは保証しません。したがって、そのような呼び出し後にスタックに新しい要素をプッシュする前には、`lua_checkstack`を使用する必要があります。

### 4.3 – 有効なインデックスと許容インデックス

APIでスタックインデックスを受け取る関数は、有効なインデックスまたは許容インデックスのみで動作します。

**有効なインデックス**とは、スタック内の実際の位置を指すインデックスのことで、その位置は1からスタックトップまでの間にあります（1 ≤ abs(index) ≤ top）。通常、インデックスで値を変更できる関数は有効なインデックスを要求します。

特に記載がない限り、有効なインデックスを受け入れる関数は擬似インデックスも受け入れます。擬似インデックスは、スタックには存在しないもののCコードからアクセス可能なLuaの値を表します。擬似インデックスは、レジストリやC関数のアップバリューにアクセスするために使用されます（§4.4参照）。

特定のスタック位置を必要とせず、スタック内の値のみを必要とする関数（クエリ関数など）は、許容インデックスで呼び出すことができます。許容インデックスは、有効なインデックス（擬似インデックスを含む）であるほか、スタックトップの後のスタックサイズ内の任意の正のインデックスであることもできます（スタックサイズまでのインデックスです）。ただし、0は許容インデックスにはなりません。特に記載がない限り、APIの関数は許容インデックスで動作します。

許容インデックスは、スタックトップとの余分なチェックを省略するために役立ちます。たとえば、C関数は第3引数を取得する際、3が有効なインデックスかを事前に確認する必要なく、直接アクセスできます。

許容インデックスで呼び出せる関数において、有効でないインデックスは仮想タイプ`LUA_TNONE`の値が入っているかのように扱われ、これは`nil`値のように振る舞います。

### 4.4 – Cクロージャ

C関数が作成される際に、いくつかの値を関連付けることができ、これによりCクロージャが作成されます（`lua_pushcclosure`参照）。これらの値はアップバリューと呼ばれ、関数が呼び出されるたびにアクセス可能です。

C関数が呼び出されるたびに、そのアップバリューは特定の擬似インデックスに配置されます。これらの擬似インデックスはマクロ`lua_upvalueindex`によって生成されます。関数に関連付けられた最初の値は`lua_upvalueindex(1)`の位置にあり、以下同様です。現在の関数のアップバリューの数を超える`lua_upvalueindex(n)`へのアクセス（ただし256以下）は、許容されるが無効なインデックスを生成します。

### 4.5 – レジストリ

Luaは「レジストリ」と呼ばれる事前定義されたテーブルを提供しており、Cコードが必要なLuaの値を格納するために使用できます。レジストリテーブルは常に擬似インデックス`LUA_REGISTRYINDEX`に位置し、これは有効なインデックスです。任意のCライブラリがこのテーブルにデータを格納できますが、他のライブラリとの衝突を避けるため、異なるキーを選択することが推奨されます。通常、キーとしてはライブラリ名を含む文字列、Cオブジェクトのアドレスを持つライトユーザーデータ、またはコード内で生成した任意のLuaオブジェクトを使用するのが良いでしょう。グローバル名と同様、アンダースコアと大文字で始まる文字列キー（例：`_VERSION`）はLuaで予約されています。

レジストリの整数キーは、補助ライブラリで実装されている参照機構やいくつかの事前定義された値に使用されています。したがって、整数キーは他の目的には使用しないでください。

新しいLua状態を作成すると、そのレジストリにはいくつかの事前定義された値が含まれます。これらの事前定義値は、`lua.h`に定数として定義された整数キーでインデックスされています。定義されている定数は以下の通りです。

- **LUA_RIDX_MAINTHREAD**: このインデックスには、状態のメインスレッドがレジストリに格納されています（メインスレッドは状態とともに作成されるスレッドです）。
- **LUA_RIDX_GLOBALS**: このインデックスにはグローバル環境がレジストリに格納されています。

### 4.6 – Cでのエラーハンドリング

Lua内部では、エラー処理にCの`longjmp`機能を使用しています（LuaをC++としてコンパイルする場合は、例外処理を使用することもできます。詳細はソースコード内の`LUAI_THROW`を参照してください）。Luaがエラーに遭遇した場合（例えばメモリ割り当てエラー、型エラー、構文エラー、実行時エラー）、エラーを発生させて`long jump`を行います。保護環境では`setjmp`を使用して復旧ポイントを設定し、エラーが発生すると最新のアクティブな復旧ポイントにジャンプします。

保護環境の外でエラーが発生した場合、Luaはパニック関数（`lua_atpanic`参照）を呼び出してから`abort`を実行し、ホストアプリケーションを終了します。パニック関数は、終了せずに（例えば自分で設定した復旧ポイントに`long jump`するなどして）この終了を回避できます。

パニック関数は、メッセージハンドラとして実行され（§2.3参照）、エラーメッセージがスタックのトップにあります。ただし、スタックのスペースに関しては保証がないため、スタックに何かをプッシュする前に空きスペースを確認する必要があります（§4.2参照）。

API内のほとんどの関数は、メモリ割り当てエラーなどの理由でエラーをスローする可能性があります。各関数のドキュメントには、エラーをスローする可能性があるかどうかが記載されています。

C関数内でエラーをスローするには、`lua_error`を呼び出します。

### 4.7 – Cでのコルーチンのyield処理

Lua内部では、コルーチンをyieldするためにCの`longjmp`機能を使用します。このため、関数`foo`がAPI関数を呼び出し、そのAPI関数がyield（直接または他のyieldを呼び出す関数を介して）する場合、`longjmp`によりCスタックからそのフレームが削除されるため、Luaは`foo`に戻れなくなります。

この問題を回避するため、LuaはAPI呼び出しをまたいでyieldしようとする際にエラーを発生させます。ただし、例外として`lua_yieldk`、`lua_callk`、および`lua_pcallk`の3つの関数はこのエラーをスローしません。これらの関数はすべて、yield後の実行を続けるための継続関数（`k`という名前のパラメータとして）を受け取ります。

継続を説明するために、いくつかの用語を定義する必要があります。Luaから呼び出されるC関数を「元の関数」と呼びます。この元の関数は、C API内の3つの関数のいずれか（「被呼び出し関数」と呼びます）を呼び出し、現在のスレッドをyieldします（被呼び出し関数が`lua_yieldk`である場合、または被呼び出し関数が`lua_callk`または`lua_pcallk`で、それらによって呼び出された関数がyieldした場合にこの状況が発生します）。

被呼び出し関数の実行中にスレッドがyieldするとします。スレッドが再開された後、最終的に被呼び出し関数の実行が終了します。しかし、yieldによってCスタックのフレームが破棄されているため、被呼び出し関数は元の関数に戻ることができません。代わりに、Luaは被呼び出し関数に引数として渡された継続関数を呼び出します。名前が示す通り、継続関数は元の関数のタスクを継続すべきものです。

Luaは継続関数を元の関数として扱います。継続関数は元の関数と同じLuaスタックを受け取り、被呼び出し関数が戻った場合と同じ状態になります（例えば、`lua_callk`の後では、関数とその引数がスタックから取り除かれ、呼び出しの結果に置き換えられます）。また、同じアップバリューも持ちます。Luaは継続関数が返すものを元の関数の返り値として扱います。

元の関数とその継続関数のLuaの状態の唯一の違いは、`lua_getctx`を呼び出した際の結果です。

### 4.8 – 関数と型

ここでは、C APIのすべての関数と型をアルファベット順にリストします。各関数には次のような指標が付いています：`[-o, +p, x]`

- 最初の項目`o`は、関数がスタックから取り出す（ポップする）要素の数です。
- 2番目の項目`p`は、関数がスタックにプッシュする要素の数です。（すべての関数は、引数をポップした後で結果をプッシュします。）
- `x|y`のような形式の項目は、状況に応じて`x`または`y`の要素をプッシュ（またはポップ）することを意味し、`?`は引数だけではポップ/プッシュする要素数を特定できないことを示します（例えば、スタックの内容によって変わる場合など）。
- 3番目の項目`x`は、関数がエラーをスローする可能性を示します。`-`はエラーを決してスローしないこと、`e`はエラーをスローする可能性があること、`v`は意図的にエラーをスローする可能性があることを意味します。

#### lua_absindex

`[-0, +0, –]`
```c
int lua_absindex (lua_State *L, int idx);
```
受け入れ可能なインデックス`idx`を絶対インデックス（スタックトップに依存しないもの）に変換します。

#### lua_Alloc

```c
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);
```

Lua状態が使用するメモリ割り当て関数の型です。アロケータ関数は`realloc`と似た機能を提供する必要がありますが、完全に同じである必要はありません。この関数の引数は以下の通りです：
- `ud`: `lua_newstate`に渡される不透明なポインタ
- `ptr`: 割り当て/再割り当て/解放されるブロックを指すポインタ
- `osize`: ブロックの元のサイズ、または割り当てるものに関するコード
- `nsize`: ブロックの新しいサイズ

`ptr`がNULLでない場合、`osize`は`ptr`が指すブロックのサイズ（割り当てまたは再割り当て時に指定されたサイズ）です。

`ptr`がNULLの場合、`osize`はLuaが割り当てようとしているオブジェクトの種類を表します。このとき、`osize`は`LUA_TSTRING`、`LUA_TTABLE`、`LUA_TFUNCTION`、`LUA_TUSERDATA`、または`LUA_TTHREAD`のいずれかです。`osize`がこれら以外の値の場合、Luaは他の用途のためにメモリを割り当てています。

Luaはアロケータ関数に以下の動作を期待します：

- `nsize`が0の場合、アロケータは`free`のように動作し、NULLを返すべきです。
- `nsize`が0でない場合、アロケータは`realloc`のように動作し、要求を満たせない場合のみNULLを返します。Luaは、`osize >= nsize`のとき、アロケータが失敗しないと想定しています。

以下は、補助ライブラリ内で`luaL_newstate`に使用されるシンプルなアロケータ関数の実装例です。

```c
static void *l_alloc (void *ud, void *ptr, size_t osize,
                      size_t nsize) {
  (void)ud;  (void)osize;  /* 使用しない */
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}
```

標準Cは、`free(NULL)`が何の影響も及ぼさないことと、`realloc(NULL, size)`が`malloc(size)`と同等であることを保証しています。このコードは、`realloc`がブロックを縮小する際に失敗しないことを前提としています（標準Cはこの動作を保証していませんが、安全な前提と考えられています）。

#### lua_arith

`[-(2|1), +1, e]`
```c
void lua_arith (lua_State *L, int op);
```

スタックトップの2つの値（または、単項の否定の場合は1つの値）に対して算術演算を行います。スタックトップの値が2番目のオペランドとして扱われ、これらの値をポップして、演算結果をプッシュします。この関数は対応するLua演算子のセマンティクスに従います（つまり、メタメソッドを呼び出す場合もあります）。

`op`の値は以下の定数のいずれかである必要があります：

- `LUA_OPADD`: 加算（`+`）
- `LUA_OPSUB`: 減算（`-`）
- `LUA_OPMUL`: 乗算（`*`）
- `LUA_OPDIV`: 除算（`/`）
- `LUA_OPMOD`: 剰余（`%`）
- `LUA_OPPOW`: べき乗（`^`）
- `LUA_OPUNM`: 数学的な否定（単項の`-`）

#### lua_atpanic

`[-0, +0, –]`
```c
lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
```

新しいパニック関数を設定し、以前のパニック関数を返します（§4.6参照）。

#### lua_call

`[-(nargs+1), +nresults, e]`
```c
void lua_call (lua_State *L, int nargs, int nresults);
```

関数を呼び出します。

関数を呼び出すには、次のプロトコルに従う必要があります。まず、呼び出す関数をスタックにプッシュし、次に引数を順番にプッシュします。最初の引数が最初にプッシュされます。最後に`lua_call`を呼び出します。`nargs`はスタックにプッシュされた引数の数です。呼び出された関数の引数と関数自体はスタックからポップされ、関数の戻り値がスタックにプッシュされます。戻り値の数は`nresults`に調整され、`nresults`が`LUA_MULTRET`の場合、すべての戻り値がプッシュされます。Luaは戻り値がスタックに収まるように調整します。戻り値は順番にスタックにプッシュされるため、呼び出し後、最後の結果がスタックトップにあります。

呼び出された関数内でエラーが発生すると、そのエラーは上位に伝播されます（`longjmp`で処理）。

次の例は、ホストプログラムが以下のLuaコードに相当する操作を行う方法を示します：

```lua
a = f("how", t.x, 14)
```

Cでの実装例：

```c
lua_getglobal(L, "f");                  /* 呼び出す関数 */
lua_pushstring(L, "how");               /* 1番目の引数 */
lua_getglobal(L, "t");                  /* インデックスされるテーブル */
lua_getfield(L, -1, "x");               /* t.xの結果（2番目の引数）をプッシュ */
lua_remove(L, -2);                      /* スタックから't'を削除 */
lua_pushinteger(L, 14);                 /* 3番目の引数 */
lua_call(L, 3, 1);                      /* 'f'を3つの引数で呼び出し、1つの結果を取得 */
lua_setglobal(L, "a");                  /* グローバル変数'a'を設定 */
```

上記のコードは「バランスが取れている」状態で、終了時にスタックは元の構成に戻ります。これは良いプログラミングの習慣とされています。

#### lua_callk

`[-(nargs + 1), +nresults, e]`
```c
void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
                lua_CFunction k);
```

この関数は`lua_call`と同様に動作しますが、呼び出された関数がyieldできるようにします（§4.7参照）。

#### lua_CFunction

```c
typedef int (*lua_CFunction) (lua_State *L);
```

C関数の型。

Luaと適切に通信するために、C関数はパラメータと結果の渡し方を定義する次のプロトコルを使用する必要があります。C関数はスタック上に直接順序でLuaから引数を受け取ります（最初の引数が最初にプッシュされます）。関数が開始されると、`lua_gettop(L)`が受け取った引数の数を返します。最初の引数（存在する場合）はインデックス1にあり、最後の引数は`lua_gettop(L)`にあります。Luaに戻り値を返すには、C関数は直接順序でスタックにプッシュするだけです（最初の結果が最初にプッシュされます）。結果以外のスタック内の他の値はLuaによって適切に破棄されます。Lua関数と同様に、Luaから呼び出されたC関数も複数の結果を返すことができます。

以下の例は、数値引数の可変個を受け取り、その平均と合計を返す関数です。

```c
static int foo (lua_State *L) {
  int n = lua_gettop(L);    /* 引数の数 */
  lua_Number sum = 0;
  int i;
  for (i = 1; i <= n; i++) {
    if (!lua_isnumber(L, i)) {
      lua_pushstring(L, "incorrect argument");
      lua_error(L);
    }
    sum += lua_tonumber(L, i);
  }
  lua_pushnumber(L, sum/n);        /* 1番目の結果 */
  lua_pushnumber(L, sum);          /* 2番目の結果 */
  return 2;                        /* 結果の数 */
}
```

#### lua_checkstack

`[-0, +0, –]`
```c
int lua_checkstack (lua_State *L, int extra);
```

スタックに最低でも`extra`個の空きスロットがあることを保証します。スタックが最大サイズ（通常は数千の要素）を超えるか、新しいスタックサイズのメモリを確保できない場合、この関数は要求を満たせずに`false`を返します。この関数はスタックを縮小することはありません。スタックがすでに新しいサイズよりも大きい場合、変更されません。

#### lua_close

`[-0, +0, –]`
```c
void lua_close (lua_State *L);
```

指定されたLua状態のすべてのオブジェクトを破棄し（対応するガベージコレクションメタメソッドがある場合は呼び出します）、この状態で使用されたすべての動的メモリを解放します。いくつかのプラットフォームでは、ホストプログラムが終了するときにすべてのリソースが自然に解放されるため、この関数を呼び出す必要はありません。一方で、デーモンやWebサーバーのように長期間動作するプログラムで複数の状態を作成する場合は、不要になった状態をすぐに閉じることが必要です。

#### lua_compare

`[-0, +0, e]`
```c
int lua_compare (lua_State *L, int index1, int index2, int op);
```

2つのLua値を比較します。`index1`の位置にある値が`index2`の位置にある値と比較して`op`を満たす場合、1を返します。そうでなければ0を返します。また、どちらかのインデックスが無効な場合も0を返します。比較は対応するLua演算子のセマンティクスに従います（つまり、メタメソッドを呼び出す場合もあります）。

`op`の値は次の定数のいずれかでなければなりません：

- `LUA_OPEQ`: 等価比較（`==`）
- `LUA_OPLT`: 小なり比較（`<`）
- `LUA_OPLE`: 以下比較（`<=`）

#### lua_concat

`[-n, +1, e]`
```c
void lua_concat (lua_State *L, int n);
```

スタックトップの`n`個の値を連結し、それらをポップして結果をトップに残します。`n`が1の場合、結果はスタック上の単一の値です（つまり、関数は何もしません）。`n`が0の場合、結果は空文字列になります。連結は通常のLuaのセマンティクスに従います（§3.4.5参照）。

#### lua_copy

`[-0, +0, –]`
```c
void lua_copy (lua_State *L, int fromidx, int toidx);
```

`fromidx`の位置にある要素を有効なインデックス`toidx`に移動し、他の要素をシフトせずにその位置の値を置き換えます。

#### lua_createtable

`[-0, +1, e]`
```c
void lua_createtable (lua_State *L, int narr, int nrec);
```

新しい空のテーブルを作成し、スタックにプッシュします。パラメータ`narr`はテーブルがシーケンスとして持つ要素数の予想、`nrec`はその他の要素数の予想です。Luaはこれらのヒントを使って新しいテーブルのメモリを事前に割り当てる場合があります。事前割り当ては、テーブルの要素数が事前にわかっている場合にパフォーマンス上の利点があります。それ以外の場合、`lua_newtable`関数を使用できます。

#### lua_dump

`[-0, +0, e]`
```c
int lua_dump (lua_State *L, lua_Writer writer, void *data);
```

関数をバイナリチャンクとしてダンプします。スタックのトップにあるLua関数を受け取り、それをバイナリチャンクとして出力します。このチャンクを再度ロードすると、ダンプされた関数と同等の関数が得られます。チャンクの各部分が生成されると、`lua_dump`は指定された`data`を使用して書き込み関数`writer`（`lua_Writer`参照）を呼び出します。

返される値は、`writer`の最後の呼び出しで返されたエラーコードです。0はエラーがないことを意味します。

この関数は、Lua関数をスタックからポップしません。

#### lua_error

`[-1, +0, v]`
```c
int lua_error (lua_State *L);
```

Luaエラーを生成します。エラーメッセージ（任意のLua型の値で構いません）はスタックトップにある必要があります。この関数は`long jump`を行うため、戻ることはありません（`luaL_error`参照）。

#### lua_gc

`[-0, +0, e]`
```c
int lua_gc (lua_State *L, int what, int data);
```

ガベージコレクタを制御します。

`what`の値に応じて、この関数は以下のタスクを実行します：

- `LUA_GCSTOP`: ガベージコレクタを停止します。
- `LUA_GCRESTART`: ガベージコレクタを再開します。
- `LUA_GCCOLLECT`: 完全なガベージコレクションサイクルを実行します。
- `LUA_GCCOUNT`: Luaが使用中のメモリの現在量（Kバイト単位）を返します。
- `LUA_GCCOUNTB`: Luaが使用中のメモリ量（バイト単位）を1024で割った余りを返します。
- `LUA_GCSTEP`: ガベージコレクションの増分ステップを実行します。ステップ「サイズ」は`data`で制御されます（大きい値ほど多くのステップが実行されます）。この値は実験的に調整する必要があります。サイクルが完了した場合、関数は1を返します。
- `LUA_GCSETPAUSE`: コレクタの停止値を新しい`data`値に設定し、以前の値を返します（§2.5参照）。
- `LUA_GCSETSTEPMUL`: コレクタのステップ乗数を新しい`data`値に設定し、以前の値を返します（§2.5参照）。
- `LUA_GCISRUNNING`: コレクタが動作中（停止していない）かを示すブール値を返します。
- `LUA_GCGEN`: コレクタを世代別モードに切り替えます（§2.5参照）。
- `LUA_GCINC`: コレクタを増分モードに切り替えます。これはデフォルトのモードです。

これらのオプションの詳細については`collectgarbage`を参照してください。

#### lua_getallocf

`[-0, +0, –]`
```c
lua_Alloc lua_getallocf (lua_State *L, void **ud);
```

指定された状態のメモリ割り当て関数を返します。`ud`がNULLでない場合、Luaは`*ud`に`lua_newstate`に渡された不透明なポインタを格納します。

#### lua_getctx

`[-0, +0, –]`
```c
int lua_getctx (lua_State *L, int *ctx);
```

継続関数（§4.7参照）がスレッドの状態とコンテキスト情報を取得するために呼び出されます。

元の関数内で呼び出されると、`lua_getctx`は常に`LUA_OK`を返し、引数`ctx`の値を変更しません。継続関数内で呼び出されると、`lua_getctx`は`LUA_YIELD`を返し、`ctx`にコンテキスト情報（継続関数と共に被呼び出し関数に渡された`ctx`引数の値）を設定します。

被呼び出し関数が`lua_pcallk`の場合、Luaは呼び出し中のエラー処理にも継続関数を呼び出すことがあります。つまり、`lua_pcallk`によって呼び出された関数でエラーが発生した場合、Luaは元の関数に戻らず継続関数を呼び出す場合があります。この場合、`lua_getctx`の呼び出しはエラーコードを返し（`lua_pcallk`が返す値）、`ctx`の値はyieldの場合と同様にコンテキスト情報が設定されます。

#### lua_getfield

`[-0, +1, e]`
```c
void lua_getfield (lua_State *L, int index, const char *k);
```

指定されたインデックスの値`t`に対し`t[k]`の値をスタックにプッシュします。この関数はLua内と同様に「インデックス」イベントのメタメソッドをトリガーすることがあります（§2.4参照）。

#### lua_getglobal

`[-0, +1, e]`
```c
void lua_getglobal (lua_State *L, const char *name);
```

指定されたグローバル`name`の値をスタックにプッシュします。

#### lua_getmetatable

`[-0, +(0|1), –]`
```c
int lua_getmetatable (lua_State *L, int index);
```

指定されたインデックスの値のメタテーブルをスタックにプッシュします。値がメタテーブルを持たない場合、関数は0を返し、スタックには何もプッシュされません。

#### lua_gettable

`[-1, +1, e]`
```c
void lua_gettable (lua_State *L, int index);
```

指定されたインデックスの値`t`に対し、スタックトップにあるキー`k`で`t[k]`の値をスタックにプッシュします。

この関数はキーをスタックからポップし、その場所に結果の値を配置します。Lua内と同様に、この関数は「インデックス」イベントのメタメソッドをトリガーすることがあります（§2.4参照）。

#### lua_gettop

`[-0, +0, –]`
```c
int lua_gettop (lua_State *L);
```

スタック内のトップ要素のインデックスを返します。インデックスは1から始まるため、この結果はスタック内の要素数と同じで、0は空のスタックを意味します。

#### lua_getuservalue

`[-0, +1, –]`
```c
void lua_getuservalue (lua_State *L, int index);
```

指定されたインデックスにあるユーザーデータに関連付けられたLuaの値をスタックにプッシュします。この値はテーブルまたは`nil`でなければなりません。

#### lua_insert

`[-1, +1, –]`
```c
void lua_insert (lua_State *L, int index);
```

スタックトップの要素を指定された有効なインデックスに移動し、このインデックス上の要素を上にシフトしてスペースを確保します。この関数は、擬似インデックスをスタック位置として使用できないため、擬似インデックスでは呼び出せません。

#### lua_Integer

```c
typedef ptrdiff_t lua_Integer;
```

Lua APIで符号付き整数値を表すために使用される型です。

デフォルトでは`ptrdiff_t`で、通常、マシンが「快適に」扱える最大の符号付き整数型です。

#### lua_isboolean

`[-0, +0, –]`
```c
int lua_isboolean (lua_State *L, int index);
```

指定されたインデックスの値がブール値であれば1を、そうでなければ0を返します。

#### lua_iscfunction

`[-0, +0, –]`
```c
int lua_iscfunction (lua_State *L, int index);
```

指定されたインデックスの値がC関数であれば1を、そうでなければ0を返します。

#### lua_isfunction

`[-0, +0, –]`
```c
int lua_isfunction (lua_State *L, int index);
```

指定されたインデックスの値が関数（CまたはLua関数）であれば1を、そうでなければ0を返します。

#### lua_islightuserdata

`[-0, +0, –]`
```c
int lua_islightuserdata (lua_State *L, int index);
```

指定されたインデックスの値がライトユーザーデータであれば1を、そうでなければ0を返します。

#### lua_isnil

`[-0, +0, –]`
```c
int lua_isnil (lua_State *L, int index);
```

指定されたインデックスの値が`nil`であれば1を、そうでなければ0を返します。

#### lua_isnone

`[-0, +0, –]`
```c
int lua_isnone (lua_State *L, int index);
```

指定されたインデックスが無効であれば1を、そうでなければ0を返します。

#### lua_isnoneornil

`[-0, +0, –]`
```c
int lua_isnoneornil (lua_State *L, int index);
```

指定されたインデックスが無効であるか、またはそのインデックスの値が`nil`であれば1を、そうでなければ0を返します。

#### lua_isnumber

`[-0, +0, –]`
```c
int lua_isnumber (lua_State *L, int index);
```

指定されたインデックスの値が数値、または数値に変換可能な文字列であれば1を、そうでなければ0を返します。

#### lua_isstring

`[-0, +0, –]`
```c
int lua_isstring (lua_State *L, int index);
```

指定されたインデックスの値が文字列、または文字列に変換可能な数値であれば1を、そうでなければ0を返します。

#### lua_istable

`[-0, +0, –]`
```c
int lua_istable (lua_State *L, int index);
```

指定されたインデックスの値がテーブルであれば1を、そうでなければ0を返します。

#### lua_isthread

`[-0, +0, –]`
```c
int lua_isthread (lua_State *L, int index);
```

指定されたインデックスの値がスレッドであれば1を、そうでなければ0を返します。

#### lua_isuserdata

`[-0, +0, –]`
```c
int lua_isuserdata (lua_State *L, int index);
```

指定されたインデックスの値がユーザーデータ（フルまたはライト）であれば1を、そうでなければ0を返します。

#### lua_len

`[-0, +1, e]`
```c
void lua_len (lua_State *L, int index);
```

指定されたインデックスの値の「長さ」を返します。これはLuaの`#`演算子と同等です（§3.4.6参照）。結果はスタックにプッシュされます。

#### lua_load

`[-0, +1, –]`
```c
int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *source,
              const char *mode);
```

Luaチャンクをロードします（実行はしません）。エラーがなければ、`lua_load`はコンパイル済みのチャンクをLua関数としてスタックトップにプッシュします。エラーがあれば、エラーメッセージをプッシュします。

`lua_load`の戻り値は以下の通りです：

- `LUA_OK`: エラーなし
- `LUA_ERRSYNTAX`: 構文エラー（前処理中のエラー）
- `LUA_ERRMEM`: メモリ割り当てエラー
- `LUA_ERRGCMM`: `__gc`メタメソッド実行中のエラー（ロードされるチャンクとは無関係で、ガベージコレクタが生成します）

`lua_load`関数は、ユーザーが提供するリーダー関数を使用してチャンクを読み込みます（`lua_Reader`参照）。`data`引数はリーダー関数に渡される不透明な値です。

`source`引数は、エラーメッセージやデバッグ情報（§4.9参照）で使用されるチャンク名を指定します。

`lua_load`は、チャンクがテキストかバイナリかを自動的に検出し、それに応じてロードします（`luac`プログラム参照）。文字列`mode`は`load`関数と同様に動作し、`NULL`は文字列`"bt"`と同等です。

`lua_load`は内部でスタックを使用するため、リーダー関数は戻り時にスタックを変更しないようにする必要があります。

結果の関数が1つのアップバリューを持つ場合、このアップバリューはレジストリ内のインデックス`LUA_RIDX_GLOBALS`に保存されたグローバル環境の値に設定されます（§4.5参照）。メインチャンクをロードする場合、このアップバリューは`_ENV`変数になります（§2.2参照）。

#### lua_newstate

`[-0, +0, –]`
```c
lua_State *lua_newstate (lua_Alloc f, void *ud);
```

新しい、独立した状態で動作するスレッドを作成します。メモリ不足によりスレッドまたは状態を作成できない場合はNULLを返します。引数`f`はメモリ割り当て関数であり、Luaはこの関数を通じてメモリ割り当てを行います。2番目の引数`ud`は、Luaが呼び出しごとにアロケータに渡す不透明なポインタです。

#### lua_newtable

`[-0, +1, e]`
```c
void lua_newtable (lua_State *L);
```

新しい空のテーブルを作成してスタックにプッシュします。これは`lua_createtable(L, 0, 0)`と同等です。

#### lua_newthread

`[-0, +1, e]`
```c
lua_State *lua_newthread (lua_State *L);
```

新しいスレッドを作成し、スタックにプッシュして、この新しいスレッドを表す`lua_State`へのポインタを返します。この関数で返される新しいスレッドは、元のスレッドとグローバル環境を共有しますが、独立した実行スタックを持っています。

スレッドを明示的に閉じたり破棄したりする関数はありません。スレッドは他のLuaオブジェクトと同様にガベージコレクションの対象になります。

#### lua_newuserdata

`[-0, +1, e]`
```c
void *lua_newuserdata (lua_State *L, size_t size);
```

指定されたサイズの新しいメモリブロックを割り当て、ブロックのアドレスを持つ新しいフルユーザーデータをスタックにプッシュし、そのアドレスを返します。このメモリはホストプログラムが自由に使用できます。

#### lua_next

`[-1, +(2|0), e]`
```c
int lua_next (lua_State *L, int index);
```

スタックからキーをポップし、指定されたインデックスのテーブルからキー–値のペアをプッシュします（指定したキーの「次の」ペア）。テーブルに要素が残っていない場合、`lua_next`は0を返し、何もプッシュしません。

典型的なテーブルの走査は次のようになります：

```c
/* テーブルはインデックス't'のスタックにあります */
lua_pushnil(L);  /* 最初のキー */
while (lua_next(L, t) != 0) {
  /* 'key'（インデックス-2）と 'value'（インデックス-1）を使用 */
  printf("%s - %s\n",
         lua_typename(L, lua_type(L, -2)),
         lua_typename(L, lua_type(L, -1)));
  /* 'value'を削除し、次の反復のために 'key'を保持 */
  lua_pop(L, 1);
}
```

テーブルを走査中に、キーに直接`lua_tolstring`を呼び出さないでください。キーが実際に文字列であることが分かっている場合を除きます。`lua_tolstring`は指定されたインデックスの値を変更する可能性があるため、次の`lua_next`呼び出しが混乱する原因になります。

テーブル走査中にテーブルを変更する際の注意点については、`next`関数を参照してください。

#### lua_Number

```c
typedef double lua_Number;
```

Luaで使用される数値の型です。デフォルトでは`double`ですが、`luaconf.h`で変更可能です。この設定ファイルを通じて、Luaの数値型を別の型（例えば`float`や`long`）に変更することができます。

#### lua_pcall

`[-(nargs + 1), +(nresults|1), –]`
```c
int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);
```

保護モードで関数を呼び出します。

`nargs`と`nresults`は`lua_call`と同じ意味を持ちます。呼び出し中にエラーがなければ、`lua_pcall`は`lua_call`と同様に動作します。しかし、エラーが発生した場合、`lua_pcall`はそのエラーをキャッチしてエラーメッセージをスタックにプッシュし、エラーコードを返します。`lua_call`と同様、関数とその引数はスタックから取り除かれます。

`msgh`が0の場合、スタックに返されるエラーメッセージは元のエラーメッセージと同じです。それ以外の場合、`msgh`はメッセージハンドラのスタックインデックスです（現在の実装では、このインデックスは擬似インデックスにはできません）。実行時エラーが発生すると、この関数はエラーメッセージを伴って呼び出され、その戻り値が`lua_pcall`によってスタックに返されるメッセージになります。

通常、メッセージハンドラはエラーメッセージにスタックトレースバックなどのデバッグ情報を追加するために使用されます。こうした情報は、`lua_pcall`の戻り後には収集できません。戻り時にはスタックが巻き戻されるためです。

`lua_pcall`関数は次のコードのいずれかを返します（`lua.h`で定義されています）：

- `LUA_OK`（0）：成功
- `LUA_ERRRUN`: 実行時エラー
- `LUA_ERRMEM`: メモリ割り当てエラー。この場合、Luaはメッセージハンドラを呼び出しません。
- `LUA_ERRERR`: メッセージハンドラの実行中に発生したエラー
- `LUA_ERRGCMM`: `__gc`メタメソッドの実行中に発生したエラー（通常、このエラーは呼び出される関数とは関係なく、ガベージコレクタによって生成されます）

#### lua_pcallk

`[-(nargs + 1), +(nresults|1), –]`
```c
int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int errfunc,
                int ctx,
                lua_CFunction k);
```

この関数は`lua_pcall`と同様に動作しますが、呼び出された関数がyieldできるようにします（§4.7参照）。

#### lua_pop

`[-n, +0, –]`
```c
void lua_pop (lua_State *L, int n);
```

スタックから`n`個の要素をポップします。

#### lua_pushboolean

`[-0, +1, –]`
```c
void lua_pushboolean (lua_State *L, int b);
```

ブール値`b`を持つ値をスタックにプッシュします。

#### lua_pushcclosure

`[-n, +1, e]`
```c
void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
```

新しいCクロージャをスタックにプッシュします。

C関数を作成する際にいくつかの値を関連付けることが可能で、これによりCクロージャを作成できます（§4.4参照）。これらの値は関数が呼び出されるときにアクセスできます。C関数に値を関連付けるには、まずこれらの値をスタックにプッシュします（複数の値がある場合、最初の値を最初にプッシュします）。次に、`lua_pushcclosure`を呼び出し、C関数をスタックにプッシュし、引数`n`で関数に関連付ける値の数を指定します。`lua_pushcclosure`はこれらの値をスタックからポップします。

`n`の最大値は255です。

`n`がゼロの場合、この関数はライトC関数を作成します。これは単なるC関数へのポインタです。この場合、メモリエラーをスローすることはありません。

#### lua_pushcfunction

`[-0, +1, –]`
```c
void lua_pushcfunction (lua_State *L, lua_CFunction f);
```

C関数をスタックにプッシュします。この関数はC関数へのポインタを受け取り、スタックに関数タイプのLua値をプッシュします。この値が呼び出されると、対応するC関数が実行されます。

Luaに登録される関数は、パラメータの受け取り方と結果の返し方について正しいプロトコルに従う必要があります（`lua_CFunction`参照）。

`lua_pushcfunction`は以下のようにマクロとして定義されています：

```c
#define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
```

このマクロでは、`f`が2回使用されます。

#### lua_pushfstring

`[-0, +1, e]`
```c
const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
```

フォーマットされた文字列をスタックにプッシュし、この文字列へのポインタを返します。これはISO Cの`sprintf`関数に似ていますが、いくつかの重要な違いがあります：

- 結果のメモリを確保する必要はありません。結果はLua文字列として扱われ、メモリの確保と解放（ガベージコレクションによる）はLuaが行います。
- 変換指定子は非常に制限されています。フラグ、幅、精度はなく、使用可能な指定子は次の通りです：`%%`（文字列に`%`を挿入）、`%s`（サイズ制限のないゼロ終端文字列を挿入）、`%f`（`lua_Number`を挿入）、`%p`（ポインタを16進数で挿入）、`%d`（intを挿入）、および`%c`（intをバイトとして挿入）。

#### lua_pushglobaltable

`[-0, +1, –]`
```c
void lua_pushglobaltable (lua_State *L);
```

グローバル環境をスタックにプッシュします。

#### lua_pushinteger

`[-0, +1, –]`
```c
void lua_pushinteger (lua_State *L, lua_Integer n);
```

値`n`を持つ整数をスタックにプッシュします。

#### lua_pushlightuserdata

`[-0, +1, –]`
```c
void lua_pushlightuserdata (lua_State *L, void *p);
```

ライトユーザーデータをスタックにプッシュします。

ユーザーデータはLua内でCの値を表現します。ライトユーザーデータは`void*`型のポインタで、個別のメタテーブルはなく、生成もされないためガベージコレクションの対象にはなりません。同じCアドレスを持つライトユーザーデータは等価とみなされます。

#### lua_pushliteral

`[-0, +1, e]`
```c
const char *lua_pushliteral (lua_State *L, const char *s);
```

このマクロは`lua_pushlstring`と同等ですが、`s`がリテラル文字列である場合にのみ使用できます。文字列の長さは自動的に計算されます。

#### lua_pushlstring

`[-0, +1, e]`
```c
const char *lua_pushlstring (lua_State *L, const char *s, size_t len);
```

サイズ`len`の`char`配列`s`が指す文字列をスタックにプッシュします。Luaは指定された文字列の内部コピーを作成するため、関数の戻り後、`s`のメモリを解放または再利用できます。文字列は埋め込みのゼロを含む任意のバイナリデータが可能です。

内部コピーのポインタを返します。

#### lua_pushnil

`[-0, +1, –]`
```c
void lua_pushnil (lua_State *L);
```

`nil`値をスタックにプッシュします。

#### lua_pushnumber

`[-0, +1, –]`
```c
void lua_pushnumber (lua_State *L, lua_Number n);
```

値`n`を持つ数値をスタックにプッシュします。

#### lua_pushstring

`[-0, +1, e]`
```c
const char *lua_pushstring (lua_State *L, const char *s);
```

ゼロ終端文字列`s`が指す文字列をスタックにプッシュします。Luaは指定された文字列の内部コピーを作成するため、関数の戻り後、`s`のメモリを解放または再利用できます。

内部コピーのポインタを返します。

`s`が`NULL`の場合、`nil`をプッシュして`NULL`を返します。

#### lua_pushthread

`[-0, +1, –]`
```c
int lua_pushthread (lua_State *L);
```

`L`が表すスレッドをスタックにプッシュします。このスレッドがその状態のメインスレッドであれば1を返します。

#### lua_pushunsigned

`[-0, +1, –]`
```c
void lua_pushunsigned (lua_State *L, lua_Unsigned n);
```

値`n`を持つ符号なし整数をスタックにプッシュします。

#### lua_pushvalue

`[-0, +1, –]`
```c
void lua_pushvalue (lua_State *L, int index);
```

指定されたインデックスにある要素のコピーをスタックにプッシュします。

#### lua_pushvfstring

`[-0, +1, e]`
```c
const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);
```

`lua_pushfstring`と同等ですが、可変長引数の代わりに`va_list`を受け取ります。

#### lua_rawequal

`[-0, +0, –]`
```c
int lua_rawequal (lua_State *L, int index1, int index2);
```

インデックス`index1`と`index2`の2つの値が、メタメソッドを使用せずに素の等価であれば1を返します。それ以外の場合は0を返します。いずれかのインデックスが無効な場合も0を返します。

#### lua_rawget

`[-1, +1, –]`
```c
void lua_rawget (lua_State *L, int index);
```

`lua_gettable`に似ていますが、メタメソッドを使用せずに生のアクセスを行います。

#### lua_rawgeti

`[-0, +1, –]`
```c
void lua_rawgeti (lua_State *L, int index, int n);
```

指定されたインデックスにあるテーブル`t`に対し`t[n]`の値をスタックにプッシュします。アクセスはメタメソッドを呼び出さない生のアクセスです。

#### lua_rawgetp

`[-0, +1, –]`
```c
void lua_rawgetp (lua_State *L, int index, const void *p);
```

指定されたインデックスにあるテーブル`t`に対し、ポインタ`p`をライトユーザーデータとして表現し、それをキーとする`t[k]`の値をスタックにプッシュします。アクセスはメタメソッドを呼び出さない生のアクセスです。

#### lua_rawlen

`[-0, +0, –]`
```c
size_t lua_rawlen (lua_State *L, int index);
```

指定されたインデックスにある値の生の「長さ」を返します。文字列の場合は文字列の長さ、テーブルの場合はメタメソッドを使用せずに長さ演算子（`#`）で得られる結果、ユーザーデータの場合は割り当てられたメモリブロックのサイズ、その他の値の場合は0を返します。

#### lua_rawset

`[-2, +0, e]`
```c
void lua_rawset (lua_State *L, int index);
```

`lua_settable`に似ていますが、メタメソッドを使用せずに生の代入を行います。

#### lua_rawseti

`[-1, +0, e]`
```c
void lua_rawseti (lua_State *L, int index, int n);
```

指定されたインデックスにあるテーブル`t`に対し、スタックトップの値`v`で`t[n] = v`を実行します。この関数は値をスタックからポップします。代入はメタメソッドを呼び出さない生の代入です。

#### lua_rawsetp

`[-1, +0, e]`
```c
void lua_rawsetp (lua_State *L, int index, const void *p);
```

指定されたインデックスにあるテーブル`t`に対し、ポインタ`p`をライトユーザーデータとして表現し、スタックトップの値`v`で`t[k] = v`を実行します。この関数は値をスタックからポップします。代入はメタメソッドを呼び出さない生の代入です。

#### lua_Reader

```c
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);
```

`lua_load`で使用されるリーダー関数です。チャンクの別の部分が必要になるたびに、`lua_load`はリーダーを呼び出し、その`data`パラメータを渡します。リーダーはチャンクの新しい部分を含むメモリブロックへのポインタを返し、`size`にブロックのサイズを設定しなければなりません。チャンクの終了を知らせるには、リーダーは`NULL`を返すか、`size`を0に設定します。リーダー関数は、ゼロより大きい任意のサイズの部分を返すことができます。

#### lua_register

`[-0, +0, e]`
```c
void lua_register (lua_State *L, const char *name, lua_CFunction f);
```

C関数`f`をグローバル`name`の新しい値として設定します。これはマクロとして定義されています：

```c
#define lua_register(L,n,f) \
       (lua_pushcfunction(L, f), lua_setglobal(L, n))
```

#### lua_remove

`[-1, +0, –]`
```c
void lua_remove (lua_State *L, int index);
```

指定されたインデックスにある要素を削除し、そのインデックスより上の要素を下にシフトして空きを埋めます。この関数は、スタック位置ではない擬似インデックスでは呼び出せません。

#### lua_replace

`[-1, +0, –]`
```c
void lua_replace (lua_State *L, int index);
```

スタックトップの要素を指定されたインデックスに移動し、他の要素をシフトせずにそのインデックスの値を置き換えます。その後、スタックトップの要素をポップします。

#### lua_resume

`[-?, +?, –]`
```c
int lua_resume (lua_State *L, lua_State *from, int nargs);
```

指定されたスレッドでコルーチンを開始および再開します。

コルーチンを開始するには、スレッドスタックにメイン関数と引数をプッシュし、引数の数を`nargs`に指定して`lua_resume`を呼び出します。この呼び出しはコルーチンが一時停止または実行を完了した時点で戻ります。戻り時のスタックには`lua_yield`で渡されたすべての値、または本体関数から返されたすべての値が含まれます。`lua_resume`は、コルーチンが一時停止した場合は`LUA_YIELD`を、エラーなく実行を完了した場合は`LUA_OK`を、エラーが発生した場合はエラーコードを返します（`lua_pcall`参照）。

エラーが発生した場合、スタックは巻き戻されないため、デバッグAPIを使用してエラーを調査できます。エラーメッセージはスタックのトップにあります。

コルーチンを再開するには、前回の`lua_yield`の結果を削除し、スタックに`yield`から返される値のみをプッシュしてから`lua_resume`を呼び出します。

`from`パラメータは、`L`を再開するコルーチンを表します。コルーチンがない場合、このパラメータは`NULL`にできます。

#### lua_setallocf

`[-0, +0, –]`
```c
void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
```

指定された状態のメモリアロケータ関数を`f`に変更し、ユーザーデータ`ud`を設定します。

#### lua_setfield

`[-1, +0, e]`
```c
void lua_setfield (lua_State *L, int index, const char *k);
```

指定されたインデックスにある`t`に対して`t[k] = v`を実行します。ここで`v`はスタックトップの値です。

この関数はスタックから値をポップします。Luaと同様、この関数は`newindex`イベントのメタメソッドを呼び出す可能性があります（§2.4参照）。

#### lua_setglobal

`[-1, +0, e]`
```c
void lua_setglobal (lua_State *L, const char *name);
```

スタックから値をポップし、それをグローバル`name`の新しい値として設定します。

#### lua_setmetatable

`[-1, +0, –]`
```c
void lua_setmetatable (lua_State *L, int index);
```

スタックからテーブルをポップし、指定されたインデックスにある値の新しいメタテーブルとして設定します。

#### lua_settable

`[-2, +0, e]`
```c
void lua_settable (lua_State *L, int index);
```

指定されたインデックスにある`t`に対して`t[k] = v`を実行します。ここで、`v`はスタックトップの値で、`k`はその下にある値です。

この関数はスタックからキーと値をポップします。Luaと同様、この関数は`newindex`イベントのメタメソッドを呼び出す可能性があります（§2.4参照）。

#### lua_settop

`[-?, +?, –]`
```c
void lua_settop (lua_State *L, int index);
```

任意のインデックスまたは0を受け取り、スタックトップをこのインデックスに設定します。新しいトップが古いトップよりも大きい場合、新しい要素は`nil`で埋められます。`index`が0の場合、スタックのすべての要素が削除されます。

#### lua_setuservalue

`[-1, +0, –]`
```c
void lua_setuservalue (lua_State *L, int index);
```

スタックからテーブルまたは`nil`をポップし、指定されたインデックスにあるユーザーデータに関連付けられた新しい値として設定します。

#### lua_State

```c
typedef struct lua_State lua_State;
```

Luaインタプリタ全体の状態を間接的に指すスレッドを表す不透明な構造体です。Luaライブラリは完全に再入可能で、グローバル変数を持ちません。状態に関するすべての情報はこの構造体を介してアクセスできます。

この構造体へのポインタは、`lua_newstate`（新しいLua状態を作成する関数）を除き、ライブラリ内のすべての関数の第一引数として渡される必要があります。

#### lua_status

`[-0, +0, –]`
```c
int lua_status (lua_State *L);
```

スレッド`L`の状態を返します。

状態は0（`LUA_OK`）であれば通常のスレッド、`lua_resume`の実行完了時にエラーが発生した場合はエラーコード、スレッドが一時停止中であれば`LUA_YIELD`です。

`LUA_OK`状態のスレッドでのみ関数を呼び出せます。`LUA_OK`または`LUA_YIELD`状態のスレッドは再開できます（新しいコルーチンの開始またはコルーチンの再開）。

#### lua_toboolean

`[-0, +0, –]`
```c
int lua_toboolean (lua_State *L, int index);
```

指定されたインデックスにあるLuaの値をCのブール値（0または1）に変換します。Luaにおけるすべてのテストと同様、`false`と`nil`以外の値であれば`lua_toboolean`は真を返し、`false`または`nil`であれば偽を返します。（実際のブール値のみを受け入れる場合は、値の型をテストするために`lua_isboolean`を使用してください。）

#### lua_tocfunction

`[-0, +0, –]`
```c
lua_CFunction lua_tocfunction (lua_State *L, int index);
```

指定されたインデックスの値をC関数に変換します。その値がC関数でなければ、`NULL`を返します。

#### lua_tointeger

`[-0, +0, –]`
```c
lua_Integer lua_tointeger (lua_State *L, int index);
```

`lua_tointegerx`と同等で、`isnum`が`NULL`と等しい場合の動作です。

#### lua_tointegerx

`[-0, +0, –]`
```c
lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);
```

指定されたインデックスのLuaの値を符号付き整数型`lua_Integer`に変換します。Luaの値が数値または数値に変換可能な文字列でなければ、`lua_tointegerx`は0を返します（§3.4.2参照）。

数値が整数でない場合は、非指定の方法で切り捨てられます。

`isnum`が`NULL`でない場合、変換が成功したかどうかを示すブール値が設定されます。

#### lua_tolstring

`[-0, +0, e]`
```c
const char *lua_tolstring (lua_State *L, int index, size_t *len);
```

指定されたインデックスのLuaの値をC文字列に変換します。`len`が`NULL`でない場合、文字列の長さが`*len`に設定されます。Luaの値が文字列または数値でなければ、この関数は`NULL`を返します。値が数値の場合、`lua_tolstring`はスタック上の実際の値を文字列に変更します（テーブルトラバーサル中にキーに対して`lua_tolstring`を適用すると、`lua_next`が混乱する可能性があります）。

`lua_tolstring`はLua状態内の文字列への完全に整列されたポインタを返します。この文字列は、最後の文字の後に必ずゼロ（`'\0'`）が付きますが、内部に他のゼロを含むこともあります。Luaはガベージコレクションを行うため、対応する値がスタックから削除された後も`lua_tolstring`が返すポインタが有効である保証はありません。

#### lua_tonumber

`[-0, +0, –]`
```c
lua_Number lua_tonumber (lua_State *L, int index);
```

`lua_tonumberx`と同等で、`isnum`が`NULL`と等しい場合の動作です。

#### lua_tonumberx

`[-0, +0, –]`
```c
lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);
```

指定されたインデックスのLuaの値をC型`lua_Number`に変換します（`lua_Number`参照）。Luaの値が数値または数値に変換可能な文字列でなければ、`lua_tonumberx`は0を返します（§3.4.2参照）。

`isnum`が`NULL`でない場合、変換が成功したかどうかを示すブール値が設定されます。

#### lua_topointer

`[-0, +0, –]`
```c
const void *lua_topointer (lua_State *L, int index);
```

指定されたインデックスの値を汎用Cポインタ（`void*`）に変換します。値はユーザーデータ、テーブル、スレッド、または関数である必要があります。それ以外の場合、`lua_topointer`は`NULL`を返します。異なるオブジェクトは異なるポインタを生成します。このポインタを元の値に戻す方法はありません。

この関数は通常、デバッグ情報にのみ使用されます。

#### lua_tostring

`[-0, +0, e]`
```c
const char *lua_tostring (lua_State *L, int index);
```

`lua_tolstring`と同等で、`len`が`NULL`と等しい場合の動作です。

#### lua_tothread

`[-0, +0, –]`
```c
lua_State *lua_tothread (lua_State *L, int index);
```

指定されたインデックスの値をLuaスレッド（`lua_State*`として表現）に変換します。この値がスレッドでなければ、関数は`NULL`を返します。

#### lua_tounsigned

`[-0, +0, –]`
```c
lua_Unsigned lua_tounsigned (lua_State *L, int index);
```

`lua_tounsignedx`と同等で、`isnum`が`NULL`と等しい場合の動作です。

#### lua_tounsignedx

`[-0, +0, –]`
```c
lua_Unsigned lua_tounsignedx (lua_State *L, int index, int *isnum);
```

指定されたインデックスのLuaの値を符号なし整数型`lua_Unsigned`に変換します。Luaの値が数値または数値に変換可能な文字列でなければ、`lua_tounsignedx`は0を返します（§3.4.2参照）。

数値が整数でない場合は、非指定の方法で切り捨てられます。数値が表現可能な範囲外である場合、最大表現値に1を加えた値で割った余りに正規化されます。

`isnum`が`NULL`でない場合、変換が成功したかどうかを示すブール値が設定されます。

#### lua_touserdata

`[-0, +0, –]`
```c
void *lua_touserdata (lua_State *L, int index);
```

指定されたインデックスの値がフルユーザーデータの場合、そのブロックアドレスを返します。値がライトユーザーデータである場合、そのポインタを返します。それ以外の場合は`NULL`を返します。

#### lua_type

`[-0, +0, –]`
```c
int lua_type (lua_State *L, int index);
```

指定された有効なインデックスの値の型を返します。インデックスが無効（ただし許容範囲）であれば`LUA_TNONE`を返します。`lua_type`が返す型は、`lua.h`で定義された以下の定数で表されます：`LUA_TNIL`、`LUA_TNUMBER`、`LUA_TBOOLEAN`、`LUA_TSTRING`、`LUA_TTABLE`、`LUA_TFUNCTION`、`LUA_TUSERDATA`、`LUA_TTHREAD`、および`LUA_TLIGHTUSERDATA`。

#### lua_typename

`[-0, +0, –]`
```c
const char *lua_typename (lua_State *L, int tp);
```

`lua_type`が返す値のうち`tp`でエンコードされた型の名前を返します。

#### lua_Unsigned

```c
typedef unsigned long lua_Unsigned;
```

Lua APIで符号なし整数値を表すために使用される型です。少なくとも32ビットの範囲を持つ必要があります。

デフォルトでは`unsigned int`または`unsigned long`のいずれかで、32ビットの値を保持できる方が選択されます。

#### lua_upvalueindex

`[-0, +0, –]`
```c
int lua_upvalueindex (int i);
```

実行中の関数の`i`番目のアップバリューを表す擬似インデックスを返します（§4.4参照）。

#### lua_version

`[-0, +0, v]`
```c
const lua_Number *lua_version (lua_State *L);
```

Luaコアに格納されたバージョン番号のアドレスを返します。`lua_State`が有効である場合、作成された状態のバージョンのアドレスを返します。`NULL`で呼び出すと、呼び出しを行っているバージョンのアドレスを返します。

#### lua_Writer

```c
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);
```

`lua_dump`で使用されるライター関数の型です。チャンクの別の部分が生成されるたびに、`lua_dump`はバッファ`p`とそのサイズ`sz`、および`lua_dump`に渡されたデータパラメータをライターに渡します。

ライターはエラーコードを返します。0はエラーがないことを示し、他の値はエラーが発生したことを示し、`lua_dump`がライターを再度呼び出さないようにします。

#### lua_xmove

`[-?, +?, –]`
```c
void lua_xmove (lua_State *from, lua_State *to, int n);
```

同じ状態の異なるスレッド間で値を交換します。

この関数は`from`のスタックから`n`個の値をポップし、それらを`to`のスタックにプッシュします。

#### lua_yield

`[-?, +?, –]`
```c
int lua_yield (lua_State *L, int nresults);
```

この関数は`lua_yieldk`と同等ですが、継続関数は持ちません（§4.7参照）。したがって、スレッドが再開されると、`lua_yield`を呼び出した関数を呼び出した関数に戻ります。

#### lua_yieldk

`[-?, +?, –]`
```c
int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k);
```

コルーチンを一時停止させます。

この関数はC関数の戻り値としてのみ呼び出す必要があります。以下のようにします：

```c
return lua_yieldk (L, n, i, k);
```

C関数がこのように`lua_yieldk`を呼び出すと、実行中のコルーチンは実行を一時停止し、このコルーチンを開始した`lua_resume`の呼び出しが戻ります。`nresults`は、`lua_resume`に結果として渡されるスタック上の値の数です。

コルーチンが再開されると、Luaは指定された継続関数`k`を呼び出し、`lua_yieldk`を呼び出したC関数の実行を再開します（§4.7参照）。継続関数は、前の関数のスタックと同じスタックを受け取り、結果が削除され、`lua_resume`に渡された引数が代わりに置かれます。さらに、継続関数は`lua_getctx`を呼び出して`ctx`の値にアクセスできます。

### 4.9 – デバッグインターフェース

Luaには組み込みのデバッグ機能はありませんが、関数とフックを介して特別なインターフェースを提供しています。このインターフェースにより、デバッガー、プロファイラー、その他のインタープリタから「内部情報」を取得するツールを構築することができます。

#### lua_Debug

```c
typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) アップバリューの数 */
  unsigned char nparams;      /* (u) パラメータの数 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* プライベート部分 */
  other fields
} lua_Debug;
```

`lua_Debug`は、関数やアクティベーションレコードに関するさまざまな情報を保持するための構造体です。`lua_getstack`は、この構造体のプライベート部分のみを後で使用するために設定します。`lua_Debug`の他のフィールドに有用な情報を設定するには、`lua_getinfo`を呼び出します。

`lua_Debug`のフィールドの意味は以下のとおりです：

- **source**: 関数を作成したチャンクのソースです。`source`が`@`で始まる場合、その関数がファイル内で定義されており、`@`の後にファイル名が続きます。`source`が`=`で始まる場合、それ以降の内容がユーザーに依存する形でソースを説明します。それ以外の場合、関数は文字列内で定義されており、`source`はその文字列になります。
- **short_src**: エラーメッセージに使用される`source`の「表示可能な」バージョンです。
- **linedefined**: 関数定義が始まる行番号です。
- **lastlinedefined**: 関数定義が終わる行番号です。
- **what**: 関数がLua関数の場合は"Lua"、C関数の場合は"C"、チャンクのメイン部分の場合は"main"という文字列です。
- **currentline**: 指定された関数が現在実行している行です。行情報がない場合、`currentline`は-1に設定されます。
- **name**: 指定された関数の適切な名前です。Luaでは関数は第一級の値であるため、固定された名前がありません。ある関数は複数のグローバル変数の値であったり、テーブルフィールドにのみ格納されていることがあります。`lua_getinfo`は関数がどのように呼び出されたかを調べ、適切な名前を見つけようとします。名前が見つからない場合、`name`は`NULL`に設定されます。
- **namewhat**: `name`フィールドの説明です。関数が呼び出された方法に応じて、`namewhat`の値は"global"、"local"、"method"、"field"、"upvalue"、または""（空文字列）になります（Luaは他のオプションが適用できない場合に空文字列を使用します）。
- **istailcall**: この関数呼び出しが末尾呼び出しであれば`true`です。この場合、このレベルの呼び出し元はスタックにありません。
- **nups**: 関数のアップバリューの数です。
- **nparams**: 関数の固定パラメータの数（C関数の場合は常に0）です。
- **isvararg**: 関数が可変引数関数であれば`true`です（C関数の場合は常に`true`）。

#### lua_gethook

`[-0, +0, –]`
```c
lua_Hook lua_gethook (lua_State *L);
```

現在のフック関数を返します。

#### lua_gethookcount

`[-0, +0, –]`
```c
int lua_gethookcount (lua_State *L);
```

現在のフックカウントを返します。

#### lua_gethookmask

`[-0, +0, –]`
```c
int lua_gethookmask (lua_State *L);
```

現在のフックマスクを返します。

#### lua_getinfo

`[-(0|1), +(0|1|2), e]`
```c
int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
```

特定の関数や関数の呼び出しに関する情報を取得します。

関数呼び出しに関する情報を得るには、`ar`パラメータは`lua_getstack`の以前の呼び出しによって設定された有効なアクティベーションレコードである必要があります。または、フックに引数として渡されたものである必要があります（`lua_Hook`参照）。

関数に関する情報を取得するには、その関数をスタックにプッシュし、`what`文字列を`>`で始めます。（この場合、`lua_getinfo`はスタックのトップから関数をポップします）。例えば、関数`f`がどの行で定義されているかを知りたい場合、以下のコードを記述します：

```c
lua_Debug ar;
lua_getglobal(L, "f");  /* グローバル 'f' を取得 */
lua_getinfo(L, ">S", &ar);
printf("%d\n", ar.linedefined);
```

文字列`what`の各文字は、構造体`ar`のフィールドを設定するか、スタックに値をプッシュするために使用されます：

- `'n'`: フィールド`name`と`namewhat`を設定します。
- `'S'`: フィールド`source`、`short_src`、`linedefined`、`lastlinedefined`、および`what`を設定します。
- `'l'`: フィールド`currentline`を設定します。
- `'t'`: フィールド`istailcall`を設定します。
- `'u'`: フィールド`nups`、`nparams`、および`isvararg`を設定します。
- `'f'`: 指定されたレベルで実行中の関数をスタックにプッシュします。
- `'L'`: インデックスがその関数で有効な行番号を示すテーブルをスタックにプッシュします。（有効な行とは、ブレークポイントを設定できるコードが関連付けられている行を指します。空行やコメントは非有効行です）

エラーが発生した場合（例えば`what`に無効なオプションがある場合）、この関数は`0`を返します。

#### lua_getlocal

`[-0, +(0|1), –]`
```c
const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);
```

指定されたアクティベーションレコードまたは関数のローカル変数に関する情報を取得します。

最初のケースでは、`ar`パラメータは`lua_getstack`の以前の呼び出しによって設定された有効なアクティベーションレコードである必要があります。または、フックに引数として渡されたものである必要があります（`lua_Hook`参照）。インデックス`n`は調べるローカル変数を選択します。変数のインデックスと名前に関する詳細は`debug.getlocal`を参照してください。

`lua_getlocal`は変数の値をスタックにプッシュし、その名前を返します。

第2のケースでは、`ar`は`NULL`である必要があり、調査する関数はスタックのトップになければなりません。この場合、可視なのはLua関数のパラメータのみで（どの変数がアクティブであるかの情報がないため）、スタックには何もプッシュされません。

インデックスがアクティブなローカル変数の数を超える場合、`NULL`を返し（かつ何もプッシュされません）。

#### lua_getstack

`[-0, +0, –]`
```c
int lua_getstack (lua_State *L, int level, lua_Debug *ar);
```

インタプリタの実行時スタックに関する情報を取得します。

この関数は、指定されたレベルで実行中の関数のアクティベーションレコードを識別するための情報を`lua_Debug`構造体に設定します。レベル`0`は現在実行中の関数を指し、レベル`n+1`はレベル`n`を呼び出した関数を指します（ただし、末尾呼び出しはスタックにカウントされません）。エラーがない場合、`lua_getstack`は`1`を返します。スタック深度を超えるレベルで呼び出すと、`0`を返します。

#### lua_getupvalue

`[-0, +(0|1), –]`
```c
const char *lua_getupvalue (lua_State *L, int funcindex, int n);
```

クロージャのアップバリューに関する情報を取得します。（Lua関数において、アップバリューは関数が使用する外部のローカル変数であり、結果としてクロージャに含まれます）。`lua_getupvalue`はアップバリューのインデックス`n`を取得し、その値をスタックにプッシュして名前を返します。`funcindex`はスタック内のクロージャを指します。（アップバリューは特定の順序を持たず、関数全体でアクティブなため、任意の順序で番号が付けられます）。

インデックスがアップバリューの数を超える場合、`NULL`を返し（かつ何もプッシュされません）。C関数の場合、すべてのアップバリューに対して空文字列`""`が名前として使用されます。

#### lua_Hook

```c
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
```

デバッグフック関数のための型。

フックが呼び出されると、`ar`引数のフィールド`event`にはフックを引き起こした特定のイベントが設定されます。Luaはこれらのイベントを次の定数で識別します：`LUA_HOOKCALL`、`LUA_HOOKRET`、`LUA_HOOKTAILCALL`、`LUA_HOOKLINE`、および`LUA_HOOKCOUNT`。さらに、行イベントの場合、フィールド`currentline`も設定されます。他のフィールドの値を取得するには、フックが`lua_getinfo`を呼び出す必要があります。

呼び出しイベントにおいて、`event`は通常の値である`LUA_HOOKCALL`か、または末尾呼び出しの`LUA_HOOKTAILCALL`になります。この場合、対応する戻りイベントは発生しません。

Luaがフックを実行中のときは、他のフックへの呼び出しを無効にします。したがって、フックが関数またはチャンクを実行するためにLuaを再度呼び出す場合、この実行中には他のフックは呼び出されません。

フック関数には継続（continuations）はありません。つまり、`lua_yieldk`、`lua_pcallk`、または`lua_callk`を非NULLの`k`と共に呼び出すことはできません。

フック関数は以下の条件でのみyieldできます。カウントと行イベントのみがyieldでき、いかなる値もyieldできません。フック関数がyieldするには、`nresults`をゼロに設定して`lua_yield`を呼び出して実行を終了する必要があります。

#### lua_sethook

```c
int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);
```

デバッグフック関数を設定します。

引数`f`はフック関数です。`mask`はフックが呼び出されるイベントを指定します。`mask`は、`LUA_MASKCALL`、`LUA_MASKRET`、`LUA_MASKLINE`、および`LUA_MASKCOUNT`のビットごとの論理和で構成されます。`count`引数は、`mask`に`LUA_MASKCOUNT`が含まれる場合にのみ意味を持ちます。各イベントに対するフックの呼び出しは以下のように行われます：

- **呼び出しフック**：インタプリタが関数を呼び出すときに呼び出されます。フックはLuaが新しい関数に入った直後、関数が引数を受け取る前に呼び出されます。
- **戻りフック**：インタプリタが関数から戻るときに呼び出されます。フックはLuaが関数を終了する直前に呼び出されます。戻り値にアクセスする標準的な方法はありません。
- **行フック**：インタプリタが新しい行のコードを実行しようとしているとき、またはコードが同じ行に戻るときに呼び出されます。（このイベントは、LuaがLua関数を実行中のときにのみ発生します）。
- **カウントフック**：インタプリタが`count`回の命令を実行した後に呼び出されます。（このイベントもLua関数の実行中にのみ発生します）。

フックを無効にするには、`mask`をゼロに設定します。

#### lua_setlocal

```c
const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);
```

指定されたアクティベーションレコードのローカル変数の値を設定します。パラメータ`ar`と`n`は`lua_getlocal`と同様です（`lua_getlocal`参照）。`lua_setlocal`はスタックのトップにある値を変数に割り当て、その名前を返します。また、値をスタックからポップします。

インデックスがアクティブなローカル変数の数を超える場合、`NULL`を返し（何もポップしません）。

#### lua_setupvalue

```c
const char *lua_setupvalue (lua_State *L, int funcindex, int n);
```

クロージャのアップバリューの値を設定します。`lua_setupvalue`はスタックのトップにある値をアップバリューに割り当て、その名前を返します。また、値をスタックからポップします。パラメータ`funcindex`と`n`は`lua_getupvalue`と同様です（`lua_getupvalue`参照）。

インデックスがアップバリューの数を超える場合、`NULL`を返し（何もポップしません）。

#### lua_upvalueid

```c
void *lua_upvalueid (lua_State *L, int funcindex, int n);
```

インデックス`funcindex`のクロージャからアップバリュー番号`n`の一意な識別子を返します。パラメータ`funcindex`と`n`は`lua_getupvalue`と同様です（`lua_getupvalue`参照）（ただし、`n`はアップバリューの数を超えてはなりません）。

この一意な識別子により、プログラムは異なるクロージャがアップバリューを共有しているかどうかを確認できます。Luaクロージャがアップバリュー（同一の外部ローカル変数を参照）を共有している場合、これらのアップバリューインデックスに対して同一のIDが返されます。

#### lua_upvaluejoin

```c
void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                      int funcindex2, int n2);
```

インデックス`funcindex1`のLuaクロージャの`n1`番目のアップバリューを、インデックス`funcindex2`のLuaクロージャの`n2`番目のアップバリューに関連付けます。

## 5 – 補助ライブラリ

補助ライブラリは、CとLuaのインターフェースをとるための便利な関数をいくつか提供します。基本APIがCとLua間の全てのやりとりのための基本的な関数を提供しているのに対し、補助ライブラリは一般的なタスクを簡便に行うための高レベルな関数を提供します。

補助ライブラリの全ての関数や型は、ヘッダファイル`lauxlib.h`に定義されており、`luaL_`というプレフィックスが付けられています。

補助ライブラリ内の全ての関数は基本APIの上に構築されており、基本APIで実行できる全ての操作を行えます。とはいえ、補助ライブラリを使用することでコードに一貫性がもたらされます。

補助ライブラリのいくつかの関数は、内部で追加のスタックスロットを使用します。補助ライブラリの関数が5つ未満のスロットを使用する場合、スタックサイズをチェックせず、十分なスロットがあると仮定して動作します。

補助ライブラリ内の関数のいくつかは、C関数の引数チェックに使用されます。これらの関数は、引数に対してフォーマットされたエラーメッセージ（例えば「不正な引数 #1」）を表示するため、他のスタック値には使用しないようにしてください。

`luaL_check*`という名前の関数は、チェックが満たされない場合、必ずエラーを発生させます。

### 5.1 – 関数と型

以下に、補助ライブラリの関数と型をアルファベット順で一覧表示します。

#### luaL_addchar

```c
void luaL_addchar (luaL_Buffer *B, char c);
```

バッファ`B`（`luaL_Buffer`を参照）にバイト`c`を追加します。

#### luaL_addlstring

```c
void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
```

バッファ`B`（`luaL_Buffer`を参照）に長さ`l`の文字列`s`を追加します。この文字列にはゼロ（`\0`）が含まれていても構いません。

#### luaL_addsize

```c
void luaL_addsize (luaL_Buffer *B, size_t n);
```

バッファ`B`（`luaL_Buffer`を参照）に、`luaL_prepbuffer`を使用して事前にバッファ領域にコピーされた長さ`n`の文字列を追加します。

#### luaL_addstring

```c
void luaL_addstring (luaL_Buffer *B, const char *s);
```

バッファ`B`（`luaL_Buffer`を参照）にヌル終端文字列`s`を追加します。この文字列にはゼロ（`\0`）が含まれていない必要があります。

#### luaL_addvalue

```c
void luaL_addvalue (luaL_Buffer *B);
```

スタックのトップにある値をバッファ`B`（`luaL_Buffer`を参照）に追加します。この関数は値をポップします。

この関数は文字列バッファに対して、スタック上に追加する値がある状態で唯一呼び出すことができる（そして呼び出さなければならない）関数です。

#### luaL_argcheck

```c
void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);
```

条件`cond`が真かどうかをチェックします。真でない場合、標準のエラーメッセージを表示してエラーを発生させます。

#### luaL_argerror

```c
int luaL_argerror (lua_State *L, int arg, const char *extramsg);
```

標準メッセージに`extramsg`を追加したエラーを発生させます。

この関数は決して戻りませんが、C関数内で`return luaL_argerror(args)`のように使用するのが一般的です。

#### luaL_Buffer

```c
typedef struct luaL_Buffer luaL_Buffer;
```

文字列バッファの型です。

文字列バッファを使用すると、CコードでLuaの文字列を部分ごとに構築することができます。使用パターンは以下の通りです：

1. `luaL_Buffer`型の変数`b`を宣言します。
2. `luaL_buffinit(L, &b)`を呼び出して初期化します。
3. `luaL_add*`関数を使ってバッファに文字列のパーツを追加します。
4. `luaL_pushresult(&b)`を呼び出して、最終的な文字列をスタックのトップにプッシュします。

もし事前に結果の文字列の合計サイズがわかっている場合は、以下のように使用できます：

1. `luaL_Buffer`型の変数`b`を宣言します。
2. `luaL_buffinitsize(L, &b, sz)`を呼び出して初期化し、サイズ`sz`のスペースを事前に確保します。
3. そのスペースに文字列をコピーします。
4. `luaL_pushresultsize(&b, sz)`を呼び出し、コピーされた結果の文字列の合計サイズ`sz`を指定します。

通常の操作中、文字列バッファは変動する数のスタックスロットを使用します。そのため、バッファを使用中は、スタックのトップがどこにあるかを把握しているとは限りません。バッファ操作の間にスタックを使うことは可能ですが、それはバランスが取れている場合に限られます。つまり、バッファ操作を呼び出した際、直前のバッファ操作直後のスタックレベルと同じレベルである必要があります（このルールの唯一の例外は`luaL_addvalue`です）。`luaL_pushresult`を呼び出した後、スタックはバッファが初期化されたときのレベルに戻り、そのトップに最終的な文字列がプッシュされます。

#### luaL_buffinit

```c
void luaL_buffinit (lua_State *L, luaL_Buffer *B);
```

バッファ`B`を初期化します。この関数はスペースを割り当てません。バッファは変数として宣言する必要があります（`luaL_Buffer`を参照）。

#### luaL_buffinitsize

```c
char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);
```

`luaL_buffinit`と`luaL_prepbuffsize`のシーケンスに相当します。

#### luaL_callmeta

```c
int luaL_callmeta (lua_State *L, int obj, const char *e);
```

メタメソッドを呼び出します。

インデックス`obj`のオブジェクトがメタテーブルを持ち、そのメタテーブルにフィールド`e`がある場合、このフィールドを呼び出し、オブジェクトを唯一の引数として渡します。この場合、この関数は`true`を返し、呼び出しの結果をスタックにプッシュします。メタテーブルやメタメソッドがない場合、この関数は`false`を返し（スタックには何もプッシュしません）。

#### luaL_checkany

```c
void luaL_checkany (lua_State *L, int arg);
```

関数が位置`arg`に任意の型（`nil`を含む）の引数を持っているかをチェックします。

#### luaL_checkint

```c
int luaL_checkint (lua_State *L, int arg);
```

関数引数`arg`が数値かどうかをチェックし、この数値を`int`にキャストして返します。

#### luaL_checkinteger

```c
lua_Integer luaL_checkinteger (lua_State *L, int arg);
```

関数引数`arg`が数値かどうかをチェックし、この数値を`lua_Integer`にキャストして返します。

#### luaL_checklong

```c
long luaL_checklong (lua_State *L, int arg);
```

関数引数`arg`が数値かどうかをチェックし、この数値を`long`にキャストして返します。

#### luaL_checklstring

```c
const char *luaL_checklstring (lua_State *L, int arg, size_t *l);
```

関数引数`arg`が文字列かどうかをチェックし、この文字列を返します。`l`が`NULL`でない場合は、`*l`に文字列の長さを格納します。

この関数は`lua_tolstring`を使用して結果を取得するため、その関数の変換や注意点が適用されます。

#### luaL_checknumber

```c
lua_Number luaL_checknumber (lua_State *L, int arg);
```

関数引数`arg`が数値かどうかをチェックし、この数値を返します。

#### luaL_checkoption

```c
int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);
```

関数引数`arg`が文字列かどうかをチェックし、この文字列が配列`lst`（NULLで終端されている必要があります）にあるかを検索します。文字列が見つかった場合、配列のインデックスを返します。引数が文字列でないか、文字列が見つからない場合はエラーを発生させます。

`def`が`NULL`でない場合、引数`arg`が存在しない、またはこの引数が`nil`の場合にデフォルト値として`def`を使用します。

これは文字列をCの列挙型（enum）にマッピングするのに便利な関数です（Luaライブラリでは通常、数値の代わりにオプションの選択に文字列を使用するのが一般的です）。

#### luaL_checkstack

```c
void luaL_checkstack (lua_State *L, int sz, const char *msg);
```

スタックサイズを`top + sz`要素まで拡張します。スタックがそのサイズまで拡張できない場合、エラーを発生させます。`msg`はエラーメッセージに追加されるテキストで、追加のテキストが不要な場合は`NULL`に設定します。

#### luaL_checkstring

```c
const char *luaL_checkstring (lua_State *L, int arg);
```

関数引数`arg`が文字列かどうかをチェックし、この文字列を返します。この関数は`lua_tolstring`を使用して結果を取得するため、その関数の変換や注意点が適用されます。

#### luaL_checktype

```c
void luaL_checktype (lua_State *L, int arg, int t);
```

関数引数`arg`が型`t`を持っているかどうかをチェックします。型`t`のエンコードは`lua_type`を参照してください。

#### luaL_checkudata

```c
void *luaL_checkudata (lua_State *L, int arg, const char *tname);
```

関数引数`arg`が型`tname`のユーザデータかどうかをチェックし、ユーザデータのアドレスを返します（`luaL_newmetatable`および`lua_touserdata`を参照してください）。

#### luaL_checkunsigned

```c
lua_Unsigned luaL_checkunsigned (lua_State *L, int arg);
```

関数引数`arg`が数値かどうかをチェックし、この数値を`lua_Unsigned`にキャストして返します。

#### luaL_checkversion

```c
void luaL_checkversion (lua_State *L);
```

呼び出しを行っているコア、Luaステートを作成したコア、および呼び出しを行っているコードが同じバージョンのLuaを使用しているかどうかをチェックします。また、呼び出しを行っているコアとLuaステートを作成したコアが同じアドレス空間を使用しているかもチェックします。

#### luaL_dofile

```c
int luaL_dofile (lua_State *L, const char *filename);
```

指定されたファイルをロードして実行します。この関数は次のマクロとして定義されています：

```c
(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
```

エラーがなければ`false`を、エラーがあれば`true`を返します。

#### luaL_dostring

```c
int luaL_dostring (lua_State *L, const char *str);
```

指定された文字列をロードして実行します。この関数は次のマクロとして定義されています：

```c
(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
```

エラーがなければ`false`を、エラーがあれば`true`を返します。

#### luaL_error

```c
int luaL_error (lua_State *L, const char *fmt, ...);
```

エラーを発生させます。エラーメッセージのフォーマットは`fmt`および追加の引数によって指定され、`lua_pushfstring`と同じ規則に従います。また、ファイル名とエラーが発生した行番号が利用可能であれば、メッセージの先頭に追加されます。この関数は返値を持たず、通常はC関数内で`return luaL_error(args);`という形で使用されます。

#### luaL_execresult

```c
int luaL_execresult (lua_State *L, int stat);
```

標準ライブラリのプロセス関連関数（`os.execute`や`io.close`）に対する戻り値を生成します。

#### luaL_fileresult

```c
int luaL_fileresult (lua_State *L, int stat, const char *fname);
```

標準ライブラリのファイル関連関数（`io.open`、`os.rename`、`file:seek`など）に対する戻り値を生成します。

#### luaL_getmetafield

```c
int luaL_getmetafield (lua_State *L, int obj, const char *e);
```

インデックス`obj`のオブジェクトのメタテーブルからフィールド`e`をスタックにプッシュします。オブジェクトにメタテーブルがない場合や、そのフィールドがメタテーブルに存在しない場合は`false`を返し、何もプッシュしません。

#### luaL_getmetatable

```c
void luaL_getmetatable (lua_State *L, const char *tname);
```

レジストリ内で名前`tname`に関連付けられたメタテーブルをスタックにプッシュします（`luaL_newmetatable`を参照してください）。

#### luaL_getsubtable

```c
int luaL_getsubtable (lua_State *L, int idx, const char *fname);
```

インデックス`idx`の値`t`において`t[fname]`がテーブルであることを保証し、そのテーブルをスタックにプッシュします。既存のテーブルが見つかった場合は`true`を返し、新しいテーブルを作成した場合は`false`を返します。

#### luaL_gsub

```c
const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);
```

文字列`s`内で文字列`p`が出現する箇所をすべて文字列`r`に置き換えたコピーを作成します。結果の文字列をスタックにプッシュし、これを返します。

#### luaL_len

```c
int luaL_len (lua_State *L, int index);
```

指定されたインデックスの値の「長さ」を数値として返します。これはLuaの`#`演算子と同等です（§3.4.6参照）。操作結果が数値でない場合、エラーを発生させます（この場合はメタメソッドを介した場合のみ発生します）。

#### luaL_loadbuffer

```c
int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);
```

`luaL_loadbufferx`と同等で、`mode`が`NULL`です。

#### luaL_loadbufferx

```c
int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);
```

バッファをLuaチャンクとしてロードします。この関数は`lua_load`を使用して、`buff`が指すバッファのサイズ`sz`を持つチャンクをロードします。

この関数は`lua_load`と同じ結果を返します。`name`はチャンクの名前で、デバッグ情報やエラーメッセージに使用されます。`mode`文字列は`lua_load`と同様に動作します。

#### luaL_loadfile

```c
int luaL_loadfile (lua_State *L, const char *filename);
```

`luaL_loadfilex`と同等で、`mode`が`NULL`です。

#### luaL_loadfilex

```c
int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);
```

ファイルをLuaチャンクとしてロードします。この関数は`lua_load`を使用して、指定されたファイル名`filename`のファイル内のチャンクをロードします。`filename`が`NULL`の場合は標準入力からロードします。ファイルの最初の行が`#`で始まる場合、その行は無視されます。

`mode`文字列は`lua_load`と同様に動作します。

この関数は`lua_load`と同じ結果を返しますが、ファイルを開いたり読み取ったりできない場合、またはファイルのモードが正しくない場合には追加のエラーコード`LUA_ERRFILE`を返します。

`lua_load`と同様に、この関数はチャンクをロードするだけで、実行はしません。

#### luaL_loadstring

```c
int luaL_loadstring (lua_State *L, const char *s);
```

文字列をLuaチャンクとしてロードします。この関数は`lua_load`を使用して、ヌル終端文字列`s`のチャンクをロードします。

この関数は`lua_load`と同じ結果を返します。また、`lua_load`と同様に、この関数はチャンクをロードするだけで、実行はしません。

#### luaL_newlib

```c
void luaL_newlib (lua_State *L, const luaL_Reg *l);
```

新しいテーブルを作成し、リスト`l`にある関数を登録します。これは次のマクロとして実装されています：

```c
(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
```

#### luaL_newlibtable

```c
void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);
```

配列`l`内のすべてのエントリを格納するのに最適なサイズの新しいテーブルを作成しますが、実際にはエントリは格納しません。これは`luaL_setfuncs`と組み合わせて使用されることを意図しています（`luaL_newlib`参照）。

これはマクロとして実装されています。配列`l`は実際の配列でなければならず、ポインタではありません。

#### luaL_newmetatable

```c
int luaL_newmetatable (lua_State *L, const char *tname);
```

レジストリに`tname`キーが既にある場合は`0`を返します。それ以外の場合、ユーザデータのメタテーブルとして使用する新しいテーブルを作成し、それを`tname`キーでレジストリに追加して`1`を返します。

どちらの場合も、最終的に`tname`に関連付けられた値をスタックにプッシュします。

#### luaL_newstate

```c
lua_State *luaL_newstate (void);
```

新しいLuaステートを作成します。標準のC`realloc`関数に基づいたアロケータを使用して`lua_newstate`を呼び出し、致命的エラーが発生した場合にエラーメッセージを標準エラー出力に出力するパニック関数を設定します（§4.6参照）。

新しいステートを返しますが、メモリアロケーションエラーが発生した場合は`NULL`を返します。

#### luaL_openlibs

```c
void luaL_openlibs (lua_State *L);
```

指定されたステートにすべての標準Luaライブラリを開きます。

#### luaL_optint

```c
int luaL_optint (lua_State *L, int arg, int d);
```

関数引数`arg`が数値の場合、その数値を`int`にキャストして返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

#### luaL_optinteger

```c
lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);
```

関数引数`arg`が数値の場合、その数値を`lua_Integer`にキャストして返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

#### luaL_optlong

```c
long luaL_optlong (lua_State *L, int arg, long d);
```

関数引数`arg`が数値の場合、その数値を`long`型にキャストして返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

#### luaL_optlstring

```c
const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);
```

関数引数`arg`が文字列の場合、その文字列を返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

`l`が`NULL`でない場合、結果の文字列の長さを`*l`に格納します。

#### luaL_optnumber

```c
lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);
```

関数引数`arg`が数値の場合、その数値を返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

#### luaL_optstring

```c
const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);
```

関数引数`arg`が文字列の場合、その文字列を返します。この引数が存在しないか`nil`の場合は`d`を返します。その他の場合はエラーを発生させます。

#### luaL_optunsigned

```c
lua_Unsigned luaL_optunsigned (lua_State *L,
                               int arg,
                               lua_Unsigned u);
```

関数引数`arg`が数値の場合、その数値を`lua_Unsigned`型にキャストして返します。この引数が存在しないか`nil`の場合は`u`を返します。その他の場合はエラーを発生させます。

#### luaL_prepbuffer

```c
char *luaL_prepbuffer (luaL_Buffer *B);
```

`luaL_prepbuffsize`と同等で、定義済みのサイズ`LUAL_BUFFERSIZE`を使用します。

#### luaL_prepbuffsize

```c
char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);
```

バッファ`B`（`luaL_Buffer`参照）に追加する文字列をコピーできるサイズ`sz`のスペースのアドレスを返します。このスペースに文字列をコピーした後、`luaL_addsize`を呼び出して文字列をバッファに実際に追加する必要があります。

#### luaL_pushresult

```c
void luaL_pushresult (luaL_Buffer *B);
```

バッファ`B`の使用を終了し、最終的な文字列をスタックのトップに残します。

#### luaL_pushresultsize

```c
void luaL_pushresultsize (luaL_Buffer *B, size_t sz);
```

`luaL_addsize`と`luaL_pushresult`のシーケンスと同等です。

#### luaL_ref

```c
int luaL_ref (lua_State *L, int t);
```

スタックのトップにあるオブジェクトに対して、インデックス`t`にあるテーブル内で参照を作成して返します（オブジェクトはポップされます）。

参照は一意の整数キーです。テーブル`t`に手動で整数キーを追加しない限り、`luaL_ref`は一意のキーを保証します。参照`r`で参照されるオブジェクトは、`lua_rawgeti(L, t, r)`を呼び出すことで取得できます。関数`luaL_unref`は参照とその関連オブジェクトを解放します。

スタックのトップのオブジェクトが`nil`の場合、`luaL_ref`は定数`LUA_REFNIL`を返します。定数`LUA_NOREF`は、`luaL_ref`によって返される参照とは異なることが保証されています。

#### luaL_Reg

```c
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
```

`luaL_setfuncs`によって登録される関数の配列の型です。`name`は関数名で、`func`は関数へのポインタです。`luaL_Reg`の配列は、`name`と`func`の両方が`NULL`である番兵エントリで終了する必要があります。

#### luaL_requiref

```c
void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);
```

関数`openf`を引数として文字列`modname`で呼び出し、その呼び出し結果を`package.loaded[modname]`に設定します。これはその関数が`require`を通じて呼び出されたかのように動作します。

`glb`が真の場合、結果もグローバル`modname`に格納されます。

その結果のコピーをスタックに残します。

#### luaL_setfuncs

```c
void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);
```

配列`l`（`luaL_Reg`参照）内のすべての関数をスタックのトップにあるテーブルに登録します（オプションのアップバリューの下に配置します。次を参照）。

`nup`がゼロでない場合、すべての関数は`nup`個のアップバリューを共有して作成され、それらの値はライブラリテーブルの上にスタックに事前にプッシュされる必要があります。登録後、これらの値はスタックからポップされます。

#### luaL_setmetatable

```c
void luaL_setmetatable (lua_State *L, const char *tname);
```

スタックのトップにあるオブジェクトのメタテーブルを、レジストリに`tname`として登録されているメタテーブルに設定します（`luaL_newmetatable`参照）。

#### luaL_testudata

```c
void *luaL_testudata (lua_State *L, int arg, const char *tname);
```

この関数は`luaL_checkudata`と同様に動作しますが、テストが失敗した場合にエラーを発生させる代わりに`NULL`を返します。

#### luaL_tolstring

```c
const char *luaL_tolstring (lua_State *L, int idx, size_t *len);
```

指定されたインデックスにある任意のLua値を、適切な形式でC文字列に変換します。変換結果の文字列はスタックにプッシュされ、この関数の戻り値としても返されます。`len`が`NULL`でない場合、文字列の長さも`*len`に設定されます。

値にメタテーブルがあり、そのメタテーブルに`"__tostring"`フィールドがある場合、`luaL_tolstring`は対応するメタメソッドを引数として呼び出し、その結果を返り値として使用します。

#### luaL_traceback

```c
void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);
```

スタック`L1`のトレースバックを作成してプッシュします。`msg`が`NULL`でない場合、それがトレースバックの先頭に追加されます。`level`パラメータはトレースバックの開始レベルを指定します。

#### luaL_typename

```c
const char *luaL_typename (lua_State *L, int index);
```

指定されたインデックスにある値の型名を返します。

#### luaL_unref

```c
void luaL_unref (lua_State *L, int t, int ref);
```

インデックス`t`のテーブルから参照`ref`を解放します（`luaL_ref`参照）。エントリはテーブルから削除されるため、参照されたオブジェクトはガベージコレクションの対象となります。また、参照`ref`は再利用可能として解放されます。

`ref`が`LUA_NOREF`または`LUA_REFNIL`の場合、`luaL_unref`は何も行いません。

#### luaL_where

```c
void luaL_where (lua_State *L, int lvl);
```

現在のコールスタックにおけるレベル`lvl`での位置を示す文字列をスタックにプッシュします。この文字列は通常、次の形式を持ちます：

```
chunkname:currentline:
```

レベル0は実行中の関数で、レベル1は実行中の関数を呼び出した関数です。

この関数はエラーメッセージのプレフィックスを作成するために使用されます。

## 6 – 標準ライブラリ

Luaの標準ライブラリは、C APIを通じて直接実装された便利な関数を提供します。これらの関数の一部は、言語にとって不可欠なサービス（例：`type`や`getmetatable`）を提供し、他は「外部」サービス（例：I/O）にアクセスする機能を提供します。また、Luaで実装可能ですが、非常に有用であるか、重要なパフォーマンス要件があるためにCでの実装が望まれるもの（例：`table.sort`）もあります。

すべてのライブラリは公式のC APIを通じて実装され、個別のCモジュールとして提供されます。現在、Luaには以下の標準ライブラリがあります：

- 基本ライブラリ（§6.1）
- コルーチンライブラリ（§6.2）
- パッケージライブラリ（§6.3）
- 文字列操作（§6.4）
- テーブル操作（§6.5）
- 数学関数（例：`sin`、`log`など）（§6.6）
- ビット演算（§6.7）
- 入出力（§6.8）
- OS関連機能（§6.9）
- デバッグ機能（§6.10）

基本ライブラリとパッケージライブラリを除き、各ライブラリはそのすべての関数をグローバルテーブルのフィールドまたはオブジェクトのメソッドとして提供します。

これらのライブラリにアクセスするには、Cホストプログラムが`luaL_openlibs`関数を呼び出し、すべての標準ライブラリを開く必要があります。または、ホストプログラムが個別に開くこともでき、`luaL_requiref`を使用して、`luaopen_base`（基本ライブラリ用）、`luaopen_package`（パッケージライブラリ用）、`luaopen_coroutine`（コルーチンライブラリ用）、`luaopen_string`（文字列ライブラリ用）、`luaopen_table`（テーブルライブラリ用）、`luaopen_math`（数学ライブラリ用）、`luaopen_bit32`（ビットライブラリ用）、`luaopen_io`（I/Oライブラリ用）、`luaopen_os`（OSライブラリ用）、および`luaopen_debug`（デバッグライブラリ用）を呼び出します。これらの関数は`lualib.h`で宣言されています。

### 6.1 – 基本関数

基本ライブラリはLuaにおけるコア機能を提供します。このライブラリをアプリケーションに含めない場合、いくつかの機能について独自の実装が必要かどうかを慎重に確認する必要があります。

#### **assert (v [, message])**

引数`v`が`false`（つまり、`nil`または`false`）の場合にエラーを発生させます。そうでない場合は、すべての引数をそのまま返します。`message`はエラーメッセージとして使用され、不在の場合はデフォルトで「assertion failed!」が表示されます。

#### **collectgarbage ([opt [, arg]])**

この関数はガベージコレクタへの汎用インターフェースです。最初の引数`opt`に応じて異なる動作を行います。

- `"collect"`：完全なガベージコレクションサイクルを実行します（デフォルトのオプション）。
- `"stop"`：ガベージコレクタの自動実行を停止します。再開されるまで、明示的に呼び出された場合のみ実行されます。
- `"restart"`：ガベージコレクタの自動実行を再開します。
- `"count"`：Luaが使用中のメモリ量（Kバイト単位）と、メモリ量のバイト単位の1024での剰余を2つの値で返します。最初の値には小数部分が含まれるため、次の等式が常に成り立ちます。
  
  ```lua
  k, b = collectgarbage("count")
  assert(k*1024 == math.floor(k)*1024 + b)
  ```
  （2番目の結果は、Luaが非浮動小数点型でコンパイルされた場合に有用です。）

- `"step"`：ガベージコレクションのステップを実行します。ステップ「サイズ」は`arg`によって制御されますが、値が大きいほど多くのステップを実行します。適切なステップサイズを調整するには`arg`の値を実験的に調整する必要があります。この関数は、コレクションサイクルが終了した場合に`true`を返します。
- `"setpause"`：コレクタの一時停止値として新しい値`arg`を設定します（§2.5参照）。前の一時停止値を返します。
- `"setstepmul"`：コレクタのステップ倍率として新しい値`arg`を設定します（§2.5参照）。前のステップ倍率を返します。
- `"isrunning"`：コレクタが実行中かどうかを示すブール値を返します（停止していない場合は`true`）。
- `"generational"`：コレクタを世代別モードに変更します（これは実験的な機能です。§2.5参照）。
- `"incremental"`：コレクタをインクリメンタルモードに変更します（デフォルトモード）。

#### **dofile ([filename])**

指定されたファイルを開き、その内容をLuaチャンクとして実行します。引数なしで呼び出された場合、標準入力（stdin）の内容を実行します。チャンクが返すすべての値を返します。エラーが発生した場合は、そのエラーを呼び出し元に伝搬させます（つまり、dofileは保護モードで実行されません）。

#### **error (message [, level])**

最後に呼び出された保護された関数を終了し、`message`をエラーメッセージとして返します。`error`関数は決して戻り値を返しません。

通常、`message`が文字列の場合、エラーの位置情報がメッセージの先頭に追加されます。`level`引数はエラー位置の特定方法を指定します。デフォルトの`1`では`error`関数が呼ばれた位置がエラー位置となり、`2`では`error`を呼び出した関数の位置がエラー位置となります。`level`に`0`を指定すると、エラーメッセージに位置情報が追加されません。

#### **_G**

グローバル変数（関数ではありません）で、グローバル環境を保持します（§2.2参照）。Lua自体はこの変数を使用せず、その値を変更しても環境には影響しませんし、その逆もありません。

#### **getmetatable (object)**

`object`にメタテーブルがなければ`nil`を返します。それ以外の場合、`object`のメタテーブルに`"__metatable"`フィールドがある場合はその値を返し、ない場合は指定されたオブジェクトのメタテーブルを返します。

#### **ipairs (t)**

`t`が`__ipairs`というメタメソッドを持っている場合、そのメタメソッドを`t`を引数にして呼び出し、その結果の最初の3つの値を返します。

それ以外の場合は、以下の3つの値を返します：反復関数、テーブル`t`、および`0`。これにより、次の構文で

```lua
for i, v in ipairs(t) do body end
```

テーブルのキー`1, t[1]`、`2, t[2]`、... など、最初に見つからなかった整数キーまで反復処理が行われます。

#### **load (ld [, source [, mode [, env]]])**

チャンクを読み込みます。

`ld`が文字列の場合、チャンクはその文字列です。`ld`が関数の場合、`load`はこの関数を繰り返し呼び出してチャンクを取得します。各呼び出しでは、前回の結果と連結できる文字列を返す必要があります。空の文字列、`nil`、または何も返さない場合はチャンクの終了を意味します。

構文エラーがなければ、コンパイル済みのチャンクを関数として返します。エラーがある場合は`nil`とエラーメッセージを返します。

結果の関数にアップバリューがある場合、最初のアップバリューは`env`の値に設定されます。`env`が指定されていない場合はグローバル環境の値が使用されます。（メインチャンクをロードする場合、結果の関数は常に1つのアップバリュー、つまり`_ENV`変数（§2.2参照）を持ちます。`string.dump`で関数から生成されたバイナリチャンクをロードする場合、任意の数のアップバリューを持つことができます。）

`source`はエラーメッセージやデバッグ情報でチャンクのソースとして使用されます（§4.9参照）。省略時には`ld`が文字列の場合は`ld`が使用され、それ以外の場合は"=(load)"が使用されます。

文字列`mode`はチャンクがテキストかバイナリ（プリコンパイルされたチャンク）かを制御します。"b"（バイナリのみ）、"t"（テキストのみ）、"bt"（両方）を指定できます。デフォルトは"bt"です。

#### **loadfile ([filename [, mode [, env]]])**

`load`と似ていますが、チャンクをファイル`filename`またはファイル名が指定されていない場合は標準入力から取得します。

#### **next (table [, index])**

テーブルのすべてのフィールドを順に処理するための関数です。最初の引数はテーブルで、2番目の引数はそのテーブルのインデックスです。`next`はテーブルの次のインデックスとその関連する値を返します。2番目の引数として`nil`を指定すると、`next`は最初のインデックスとその値を返します。最後のインデックス、または空のテーブルに`nil`を指定すると、`next`は`nil`を返します。2番目の引数が省略されると、`nil`として扱われます。特に、`next(t)`を使用してテーブルが空かどうかを確認できます。

インデックスの列挙順は指定されていません（数値インデックスで処理する場合は、数値用の`for`ループを使用してください）。

テーブルの処理中に存在しないフィールドに値を割り当てると、`next`の動作は未定義になります。ただし、既存のフィールドの変更は可能です。特に、既存のフィールドをクリアすることができます。

#### **pairs (t)**

`t`が`__pairs`というメタメソッドを持っている場合、そのメタメソッドを`t`を引数にして呼び出し、その結果の最初の3つの値を返します。

それ以外の場合は、`next`関数、テーブル`t`、および`nil`の3つの値を返し、以下の構文で

```lua
for k, v in pairs(t) do body end
```

テーブル`t`のすべてのキーと値のペアを反復処理できます。

テーブルの処理中にテーブルを変更する際の注意点については`next`関数を参照してください。

#### **pcall (f [, arg1, ···])**

指定された引数で関数`f`を保護モードで呼び出します。これにより、`f`内で発生するエラーは伝播されず、`pcall`がエラーをキャッチして状態コードを返します。最初の戻り値は状態コード（ブール値）で、エラーがなく正常に終了した場合は`true`です。この場合、`pcall`はこの最初の戻り値に続けて関数呼び出しの結果をすべて返します。エラーが発生した場合、`pcall`は`false`とエラーメッセージを返します。

#### **print (···)**

任意の数の引数を受け取り、それらの値を標準出力（stdout）に表示します。各引数は`tostring`関数を使用して文字列に変換されます。`print`は、フォーマットされた出力を意図したものではなく、デバッグなどで値を素早く表示するために使用されます。出力を完全に制御するには、`string.format`と`io.write`を使用してください。

#### **rawequal (v1, v2)**

メタメソッドを呼び出さずに、`v1`と`v2`が等しいかを確認します。ブール値を返します。

#### **rawget (table, index)**

メタメソッドを呼び出さずに、`table[index]`の実際の値を取得します。`table`はテーブルでなければならず、`index`は任意の値です。

#### **rawlen (v)**

オブジェクト`v`の長さを返します。`v`はテーブルまたは文字列でなければなりません。メタメソッドを呼び出さずに、整数値として返します。

#### **rawset (table, index, value)**

メタメソッドを呼び出さずに、`table[index]`に`value`を設定します。`table`はテーブル、`index`は`nil`や`NaN`以外の任意の値、`value`は任意のLuaの値です。この関数は`table`を返します。

select (index, ···)

If index is a number, returns all arguments after argument number index; a negative number indexes from the end (-1 is the last argument). Otherwise, index must be the string "#", and select returns the total number of extra arguments it received.

setmetatable (table, metatable)

Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a "__metatable" field, raises an error.

This function returns table.

tonumber (e [, base])

When called with no base, tonumber tries to convert its argument to a number. If the argument is already a number or a string convertible to a number (see §3.4.2), then tonumber returns this number; otherwise, it returns nil.

When called with base, then e should be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. If the string e is not a valid numeral in the given base, the function returns nil.

tostring (v)

Receives a value of any type and converts it to a string in a reasonable format. (For complete control of how numbers are converted, use string.format.)
If the metatable of v has a "__tostring" field, then tostring calls the corresponding value with v as argument, and uses the result of the call as its result.

type (v)

Returns the type of its only argument, coded as a string. The possible results of this function are "nil" (a string, not the value nil), "number", "string", "boolean", "table", "function", "thread", and "userdata".
_VERSION

A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is "Lua 5.2".
xpcall (f, msgh [, arg1, ···])

This function is similar to pcall, except that it sets a new message handler msgh.

6.2 – Coroutine Manipulation

The operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. See §2.6 for a general description of coroutines.

coroutine.create (f)

Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type "thread".

coroutine.resume (co [, val1, ···])

Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ... are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ... are passed as the results from the yield.

If the coroutine runs without any errors, resume returns true plus any values passed to yield (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, resume returns false plus the error message.

coroutine.running ()

Returns the running coroutine plus a boolean, true when the running coroutine is the main one.

coroutine.status (co)

Returns the status of coroutine co, as a string: "running", if the coroutine is running (that is, it called status); "suspended", if the coroutine is suspended in a call to yield, or if it has not started running yet; "normal" if the coroutine is active but not running (that is, it has resumed another coroutine); and "dead" if the coroutine has finished its body function, or if it has stopped with an error.

coroutine.wrap (f)

Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error.

coroutine.yield (···)

Suspends the execution of the calling coroutine. Any arguments to yield are passed as extra results to resume.

6.3 – Modules

The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: require. Everything else is exported in a table package.

require (modname)

Loads the given module. The function starts by looking into the package.loaded table to determine whether modname is already loaded. If it is, then require returns the value stored at package.loaded[modname]. Otherwise, it tries to find a loader for the module.

To find a loader, require is guided by the package.searchers sequence. By changing this sequence, we can change how require looks for a module. The following explanation is based on the default configuration for package.searchers.

First require queries package.preload[modname]. If it has a value, this value (which should be a function) is the loader. Otherwise require searches for a Lua loader using the path stored in package.path. If that also fails, it searches for a C loader using the path stored in package.cpath. If that also fails, it tries an all-in-one loader (see package.searchers).

Once a loader is found, require calls the loader with two arguments: modname and an extra value dependent on how it got the loader. (If the loader came from a file, this extra value is the file name.) If the loader returns any non-nil value, require assigns the returned value to package.loaded[modname]. If the loader does not return a non-nil value and has not assigned any value to package.loaded[modname], then require assigns true to this entry. In any case, require returns the final value of package.loaded[modname].

If there is any error loading or running the module, or if it cannot find any loader for the module, then require raises an error.

package.config

A string describing some compile-time configurations for packages. This string is a sequence of lines:

The first line is the directory separator string. Default is '\' for Windows and '/' for all other systems.
The second line is the character that separates templates in a path. Default is ';'.
The third line is the string that marks the substitution points in a template. Default is '?'.
The fourth line is a string that, in a path in Windows, is replaced by the executable's directory. Default is '!'.
The fifth line is a mark to ignore all text before it when building the luaopen_ function name. Default is '-'.
package.cpath

The path used by require to search for a C loader.

Lua initializes the C path package.cpath in the same way it initializes the Lua path package.path, using the environment variable LUA_CPATH_5_2 or the environment variable LUA_CPATH or a default path defined in luaconf.h.

package.loaded

A table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there.

This variable is only a reference to the real table; assignments to this variable do not change the table used by require.

package.loadlib (libname, funcname)

Dynamically links the host program with the C library libname.

If funcname is "*", then it only links with the library, making the symbols exported by the library available to other dynamically linked libraries. Otherwise, it looks for a function funcname inside the library and returns this function as a C function. So, funcname must follow the lua_CFunction prototype (see lua_CFunction).

This is a low-level function. It completely bypasses the package and module system. Unlike require, it does not perform any path searching and does not automatically adds extensions. libname must be the complete file name of the C library, including if necessary a path and an extension. funcname must be the exact name exported by the C library (which may depend on the C compiler and linker used).

This function is not supported by Standard C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard).

package.path

The path used by require to search for a Lua loader.

At start-up, Lua initializes this variable with the value of the environment variable LUA_PATH_5_2 or the environment variable LUA_PATH or with a default path defined in luaconf.h, if those environment variables are not defined. Any ";;" in the value of the environment variable is replaced by the default path.

package.preload

A table to store loaders for specific modules (see require).

This variable is only a reference to the real table; assignments to this variable do not change the table used by require.

package.searchers

A table used by require to control how to load modules.

Each entry in this table is a searcher function. When looking for a module, require calls each of these searchers in ascending order, with the module name (the argument given to require) as its sole parameter. The function can return another function (the module loader) plus an extra value that will be passed to that loader, or a string explaining why it did not find that module (or nil if it has nothing to say).

Lua initializes this table with four searcher functions.

The first searcher simply looks for a loader in the package.preload table.

The second searcher looks for a loader as a Lua library, using the path stored at package.path. The search is done as described in function package.searchpath.

The third searcher looks for a loader as a C library, using the path given by the variable package.cpath. Again, the search is done as described in function package.searchpath. For instance, if the C path is the string

     "./?.so;./?.dll;/usr/local/?/init.so"
the searcher for module foo will try to open the files ./foo.so, ./foo.dll, and /usr/local/foo/init.so, in that order. Once it finds a C library, this searcher first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside the library to be used as the loader. The name of this C function is the string "luaopen_" concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is a.v1-b.c, the function name will be luaopen_b_c.

The fourth searcher tries an all-in-one loader. It searches the C path for a library for the root name of the given module. For instance, when requiring a.b.c, it will search for a C library for a. If found, it looks into it for an open function for the submodule; in our example, that would be luaopen_a_b_c. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.

All searchers except the first one (preload) return as the extra value the file name where the module was found, as returned by package.searchpath. The first searcher returns no extra value.

package.searchpath (name, path [, sep [, rep]])

Searches for the given name in the given path.

A path is a string containing a sequence of templates separated by semicolons. For each template, the function replaces each interrogation mark (if any) in the template with a copy of name wherein all occurrences of sep (a dot, by default) were replaced by rep (the system's directory separator, by default), and then tries to open the resulting file name.

For instance, if the path is the string

     "./?.lua;./?.lc;/usr/local/?/init.lua"
the search for the name foo.a will try to open the files ./foo/a.lua, ./foo/a.lc, and /usr/local/foo/a/init.lua, in that order.

Returns the resulting name of the first file that it can open in read mode (after closing the file), or nil plus an error message if none succeeds. (This error message lists all file names it tried to open.)

6.4 – String Manipulation

This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.

The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style. For instance, string.byte(s,i) can be written as s:byte(i).

The string library assumes one-byte character encodings.

string.byte (s [, i [, j]])

Returns the internal numerical codes of the characters s[i], s[i+1], ..., s[j]. The default value for i is 1; the default value for j is i. These indices are corrected following the same rules of function string.sub.
Numerical codes are not necessarily portable across platforms.

string.char (···)

Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument.
Numerical codes are not necessarily portable across platforms.

string.dump (function)

Returns a string containing a binary representation of the given function, so that a later load on this string returns a copy of the function (but with new upvalues).

string.find (s, pattern [, init [, plain]])

Looks for the first match of pattern in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain "find substring" operation, with no characters in pattern being considered magic. Note that if plain is given, then init must be given as well.

If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.

string.format (formatstring, ···)

Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function sprintf. The only differences are that the options/modifiers *, h, L, l, n, and p are not supported and that there is an extra option, q. The q option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call

     string.format('%q', 'a string with "quotes" and \n new line')
may produce the string:

     "a string with \"quotes\" and \
      new line"
Options A and a (when available), E, e, f, G, and g all expect a number as argument. Options c, d, i, o, u, X, and x also expect a number, but the range of that number may be limited by the underlying C implementation. For options o, u, X, and x, the number cannot be negative. Option q expects a string; option s expects a string without embedded zeros. If the argument to option s is not a string, it is converted to one following the same rules of tostring.

string.gmatch (s, pattern)

Returns an iterator function that, each time it is called, returns the next captures from pattern over the string s. If pattern specifies no captures, then the whole match is produced in each call.
As an example, the following loop will iterate over all the words from string s, printing one per line:

     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
The next example collects all pairs key=value from the given string into a table:

     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
For this function, a caret '^' at the start of a pattern does not work as an anchor, as this would prevent the iteration.

string.gsub (s, pattern, repl [, n])

Returns a copy of s in which all (or the first n, if given) occurrences of the pattern have been replaced by a replacement string specified by repl, which can be a string, a table, or a function. gsub also returns, as its second value, the total number of matches that occurred. The name gsub comes from Global SUBstitution.
If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %d, with d between 1 and 9, stands for the value of the d-th captured substring. The sequence %0 stands for the whole match. The sequence %% stands for a single %.

If repl is a table, then the table is queried for every match, using the first capture as the key.

If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order.

In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.

If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string).

Here are some examples:

     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --> x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --> x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --> x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --> x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --> x="4+5 = 9"
     
     local t = {name="lua", version="5.2"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --> x="lua-5.2.tar.gz"
string.len (s)

Receives a string and returns its length. The empty string "" has length 0. Embedded zeros are counted, so "a\000bc\000" has length 5.
string.lower (s)

Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.
string.match (s, pattern [, init])

Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative.
string.rep (s, n [, sep])

Returns a string that is the concatenation of n copies of the string s separated by the string sep. The default value for sep is the empty string (that is, no separator).
string.reverse (s)

Returns a string that is the string s reversed.
string.sub (s, i [, j])

Returns the substring of s that starts at i and continues until j; i and j can be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i.
If, after the translation of negative indices, i is less than 1, it is corrected to 1. If j is greater than the string length, it is corrected to that length. If, after these corrections, i is greater than j, the function returns the empty string.

string.upper (s)

Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.
6.4.1 – Patterns

Character Class:

A character class is used to represent a set of characters. The following combinations are allowed in describing a character class:

x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.
.: (a dot) represents all characters.
%a: represents all letters.
%c: represents all control characters.
%d: represents all digits.
%g: represents all printable characters except space.
%l: represents all lowercase letters.
%p: represents all punctuation characters.
%s: represents all space characters.
%u: represents all uppercase letters.
%w: represents all alphanumeric characters.
%x: represents all hexadecimal digits.
%x: (where x is any non-alphanumeric character) represents the character x. This is the standard way to escape the magic characters. Any punctuation character (even the non magic) can be preceded by a '%' when used to represent itself in a pattern.
[set]: represents the class which is the union of all characters in set. A range of characters can be specified by separating the end characters of the range, in ascending order, with a '-', All classes %x described above can also be used as components in set. All other characters in set represent themselves. For example, [%w_] (or [_%w]) represents all alphanumeric characters plus the underscore, [0-7] represents the octal digits, and [0-7%l%-] represents the octal digits plus the lowercase letters plus the '-' character.
The interaction between ranges and classes is not defined. Therefore, patterns like [%a-z] or [a-%%] have no meaning.

[^set]: represents the complement of set, where set is interpreted as above.
For all classes represented by single letters (%a, %c, etc.), the corresponding uppercase letter represents the complement of the class. For instance, %S represents all non-space characters.

The definitions of letter, space, and other character groups depend on the current locale. In particular, the class [a-z] may not be equivalent to %l.

Pattern Item:

A pattern item can be

a single character class, which matches any single character in the class;
a single character class followed by '*', which matches 0 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;
a single character class followed by '+', which matches 1 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;
a single character class followed by '-', which also matches 0 or more repetitions of characters in the class. Unlike '*', these repetition items will always match the shortest possible sequence;
a single character class followed by '?', which matches 0 or 1 occurrence of a character in the class;
%n, for n between 1 and 9; such item matches a substring equal to the n-th captured string (see below);
%bxy, where x and y are two distinct characters; such item matches strings that start with x, end with y, and where the x and y are balanced. This means that, if one reads the string from left to right, counting +1 for an x and -1 for a y, the ending y is the first y where the count reaches 0. For instance, the item %b() matches expressions with balanced parentheses.
%f[set], a frontier pattern; such item matches an empty string at any position such that the next character belongs to set and the previous character does not belong to set. The set set is interpreted as previously described. The beginning and the end of the subject are handled as if they were the character '\0'.
Pattern:

A pattern is a sequence of pattern items. A caret '^' at the beginning of a pattern anchors the match at the beginning of the subject string. A '$' at the end of a pattern anchors the match at the end of the subject string. At other positions, '^' and '$' have no special meaning and represent themselves.

Captures:

A pattern can contain sub-patterns enclosed in parentheses; they describe captures. When a match succeeds, the substrings of the subject string that match captures are stored (captured) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the part of the string matching "a*(.)%w(%s*)" is stored as the first capture (and therefore has number 1); the character matching "." is captured with number 2, and the part matching "%s*" has number 3.

As a special case, the empty capture () captures the current string position (a number). For instance, if we apply the pattern "()aa()" on the string "flaaap", there will be two captures: 3 and 5.

6.5 – Table Manipulation

This library provides generic functions for table manipulation. It provides all its functions inside the table table.

Remember that, whenever an operation needs the length of a table, the table should be a proper sequence or have a __len metamethod (see §3.4.6). All functions ignore non-numeric keys in tables given as arguments.

For performance reasons, all table accesses (get/set) performed by these functions are raw.

table.concat (list [, sep [, i [, j]]])

Given a list where all elements are strings or numbers, returns the string list[i]..sep..list[i+1] ··· sep..list[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is #list. If i is greater than j, returns the empty string.

table.insert (list, [pos,] value)

Inserts element value at position pos in list, shifting up the elements list[pos], list[pos+1], ···, list[#list]. The default value for pos is #list+1, so that a call table.insert(t,x) inserts x at the end of list t.

table.pack (···)

Returns a new table with all parameters stored into keys 1, 2, etc. and with a field "n" with the total number of parameters. Note that the resulting table may not be a sequence.

table.remove (list [, pos])

Removes from list the element at position pos, returning the value of the removed element. When pos is an integer between 1 and #list, it shifts down the elements list[pos+1], list[pos+2], ···, list[#list] and erases element list[#list]; The index pos can also be 0 when #list is 0, or #list + 1; in those cases, the function erases the element list[pos].

The default value for pos is #list, so that a call table.remove(t) removes the last element of list t.

table.sort (list [, comp])

Sorts list elements in a given order, in-place, from list[1] to list[#list]. If comp is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that not comp(list[i+1],list[i]) will be true after the sort). If comp is not given, then the standard Lua operator < is used instead.

The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.

table.unpack (list [, i [, j]])

Returns the elements from the given table. This function is equivalent to

     return list[i], list[i+1], ···, list[j]
By default, i is 1 and j is #list.

6.6 – Mathematical Functions

This library is an interface to the standard C math library. It provides all its functions inside the table math.

math.abs (x)

Returns the absolute value of x.

math.acos (x)

Returns the arc cosine of x (in radians).

math.asin (x)

Returns the arc sine of x (in radians).

math.atan (x)

Returns the arc tangent of x (in radians).

math.atan2 (y, x)

Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)

math.ceil (x)

Returns the smallest integer larger than or equal to x.

math.cos (x)

Returns the cosine of x (assumed to be in radians).

math.cosh (x)

Returns the hyperbolic cosine of x.

math.deg (x)

Returns the angle x (given in radians) in degrees.

math.exp (x)

Returns the value ex.

math.floor (x)

Returns the largest integer smaller than or equal to x.

math.fmod (x, y)

Returns the remainder of the division of x by y that rounds the quotient towards zero.

math.frexp (x)

Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).

math.huge

The value HUGE_VAL, a value larger than or equal to any other numerical value.

math.ldexp (m, e)

Returns m2e (e should be an integer).

math.log (x [, base])

Returns the logarithm of x in the given base. The default for base is e (so that the function returns the natural logarithm of x).

math.max (x, ···)

Returns the maximum value among its arguments.

math.min (x, ···)

Returns the minimum value among its arguments.

math.modf (x)

Returns two numbers, the integral part of x and the fractional part of x.

math.pi

The value of π.

math.pow (x, y)

Returns xy. (You can also use the expression x^y to compute this value.)

math.rad (x)

Returns the angle x (given in degrees) in radians.

math.random ([m [, n]])

This function is an interface to the simple pseudo-random generator function rand provided by Standard C. (No guarantees can be given for its statistical properties.)

When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].

math.randomseed (x)

Sets x as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.

math.sin (x)

Returns the sine of x (assumed to be in radians).

math.sinh (x)

Returns the hyperbolic sine of x.

math.sqrt (x)

Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)

math.tan (x)

Returns the tangent of x (assumed to be in radians).

math.tanh (x)

Returns the hyperbolic tangent of x.

6.7 – Bitwise Operations

This library provides bitwise operations. It provides all its functions inside the table bit32.

Unless otherwise stated, all functions accept numeric arguments in the range (-251,+251); each argument is normalized to the remainder of its division by 232 and truncated to an integer (in some unspecified way), so that its final value falls in the range [0,232 - 1]. Similarly, all results are in the range [0,232 - 1]. Note that bit32.bnot(0) is 0xFFFFFFFF, which is different from -1.

bit32.arshift (x, disp)

Returns the number x shifted disp bits to the right. The number disp may be any representable integer. Negative displacements shift to the left.

This shift operation is what is called arithmetic shift. Vacant bits on the left are filled with copies of the higher bit of x; vacant bits on the right are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero or 0xFFFFFFFF (all original bits are shifted out).

bit32.band (···)

Returns the bitwise and of its operands.

bit32.bnot (x)

Returns the bitwise negation of x. For any integer x, the following identity holds:

     assert(bit32.bnot(x) == (-1 - x) % 2^32)
bit32.bor (···)

Returns the bitwise or of its operands.

bit32.btest (···)

Returns a boolean signaling whether the bitwise and of its operands is different from zero.

bit32.bxor (···)

Returns the bitwise exclusive or of its operands.

bit32.extract (n, field [, width])

Returns the unsigned number formed by the bits field to field + width - 1 from n. Bits are numbered from 0 (least significant) to 31 (most significant). All accessed bits must be in the range [0, 31].

The default for width is 1.

bit32.replace (n, v, field [, width])

Returns a copy of n with the bits field to field + width - 1 replaced by the value v. See bit32.extract for details about field and width.

bit32.lrotate (x, disp)

Returns the number x rotated disp bits to the left. The number disp may be any representable integer.

For any valid displacement, the following identity holds:

     assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))
In particular, negative displacements rotate to the right.

bit32.lshift (x, disp)

Returns the number x shifted disp bits to the left. The number disp may be any representable integer. Negative displacements shift to the right. In any direction, vacant bits are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero (all bits are shifted out).

For positive displacements, the following equality holds:

     assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)
bit32.rrotate (x, disp)

Returns the number x rotated disp bits to the right. The number disp may be any representable integer.

For any valid displacement, the following identity holds:

     assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))
In particular, negative displacements rotate to the left.

bit32.rshift (x, disp)

Returns the number x shifted disp bits to the right. The number disp may be any representable integer. Negative displacements shift to the left. In any direction, vacant bits are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero (all bits are shifted out).

For positive displacements, the following equality holds:

     assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))
This shift operation is what is called logical shift.

6.8 – Input and Output Facilities

The I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file descriptors.

When using implicit file descriptors, all operations are supplied by table io. When using explicit file descriptors, the operation io.open returns a file descriptor and then all operations are supplied as methods of the file descriptor.

The table io also provides three predefined file descriptors with their usual meanings from C: io.stdin, io.stdout, and io.stderr. The I/O library never closes these files.

Unless otherwise stated, all I/O functions return nil on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from nil on success. On non-Posix systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable errno.

io.close ([file])

Equivalent to file:close(). Without a file, closes the default output file.

io.flush ()

Equivalent to io.output():flush().

io.input ([file])

When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.

In case of errors this function raises the error, instead of returning an error code.

io.lines ([filename ···])

Opens the given file name in read mode and returns an iterator function that works like file:lines(···) over the opened file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file.

The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.

In case of errors this function raises the error, instead of returning an error code.

io.open (filename [, mode])

This function opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message.

The mode string can be any of the following:

"r": read mode (the default);
"w": write mode;
"a": append mode;
"r+": update mode, all previous data is preserved;
"w+": update mode, all previous data is erased;
"a+": append update mode, previous data is preserved, writing is only allowed at the end of file.
The mode string can also have a 'b' at the end, which is needed in some systems to open the file in binary mode.

io.output ([file])

Similar to io.input, but operates over the default output file.

io.popen (prog [, mode])

This function is system dependent and is not available on all platforms.

Starts program prog in a separated process and returns a file handle that you can use to read data from this program (if mode is "r", the default) or to write data to this program (if mode is "w").

io.read (···)

Equivalent to io.input():read(···).

io.tmpfile ()

Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.

io.type (obj)

Checks whether obj is a valid file handle. Returns the string "file" if obj is an open file handle, "closed file" if obj is a closed file handle, or nil if obj is not a file handle.

io.write (···)

Equivalent to io.output():write(···).

file:close ()

Closes file. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.

When closing a file handle created with io.popen, file:close returns the same values returned by os.execute.

file:flush ()

Saves any written data to file.

file:lines (···)

Returns an iterator function that, each time it is called, reads the file according to the given formats. When no format is given, uses "*l" as a default. As an example, the construction

     for c in file:lines(1) do body end
will iterate over all characters of the file, starting at the current position. Unlike io.lines, this function does not close the file when the loop ends.

In case of errors this function raises the error, instead of returning an error code.

file:read (···)

Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the next line (see below).

The available formats are

"*n": reads a number; this is the only format that returns a number instead of a string.
"*a": reads the whole file, starting at the current position. On end of file, it returns the empty string.
"*l": reads the next line skipping the end of line, returning nil on end of file. This is the default format.
"*L": reads the next line keeping the end of line (if present), returning nil on end of file.
number: reads a string with up to this number of bytes, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file.
file:seek ([whence [, offset]])

Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence, as follows:

"set": base is position 0 (beginning of the file);
"cur": base is current position;
"end": base is end of file;
In case of success, seek returns the final file position, measured in bytes from the beginning of the file. If seek fails, it returns nil, plus a string describing the error.

The default value for whence is "cur", and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek("set") sets the position to the beginning of the file (and returns 0); and the call file:seek("end") sets the position to the end of the file, and returns its size.

file:setvbuf (mode [, size])

Sets the buffering mode for an output file. There are three available modes:

"no": no buffering; the result of any output operation appears immediately.
"full": full buffering; output operation is performed only when the buffer is full or when you explicitly flush the file (see io.flush).
"line": line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).
For the last two cases, size specifies the size of the buffer, in bytes. The default is an appropriate size.

file:write (···)

Writes the value of each of its arguments to file. The arguments must be strings or numbers.

In case of success, this function returns file. Otherwise it returns nil plus a string describing the error.

6.9 – Operating System Facilities

This library is implemented through table os.

os.clock ()

Returns an approximation of the amount in seconds of CPU time used by the program.

os.date ([format [, time]])

Returns a string or a table containing date and time, formatted according to the given string format.

If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time.

If format starts with '!', then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string "*t", then date returns a table with the following fields: year (four digits), month (1–12), day (1–31), hour (0–23), min (0–59), sec (0–61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean). This last field may be absent if the information is not available.

If format is not "*t", then date returns the date as a string, formatted according to the same rules as the ISO C function strftime.

When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date("%c")).

On non-Posix systems, this function may be not thread safe because of its reliance on C function gmtime and C function localtime.

os.difftime (t2, t1)

Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.

os.execute ([command])

This function is equivalent to the ISO C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string and a number, as follows:

"exit": the command terminated normally; the following number is the exit status of the command.
"signal": the command was terminated by a signal; the following number is the signal that terminated the command.
When called without a command, os.execute returns a boolean that is true if a shell is available.

os.exit ([code [, close])

Calls the ISO C function exit to terminate the host program. If code is true, the returned status is EXIT_SUCCESS; if code is false, the returned status is EXIT_FAILURE; if code is a number, the returned status is this number. The default value for code is true.

If the optional second argument close is true, closes the Lua state before exiting.

os.getenv (varname)

Returns the value of the process environment variable varname, or nil if the variable is not defined.

os.remove (filename)

Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns nil, plus a string describing the error and the error code.

os.rename (oldname, newname)

Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error and the error code.

os.setlocale (locale [, category])

Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: "all", "collate", "ctype", "monetary", "numeric", or "time"; the default category is "all". The function returns the name of the new locale, or nil if the request cannot be honored.

If locale is the empty string, the current locale is set to an implementation-defined native locale. If locale is the string "C", the current locale is set to the standard C locale.

When called with nil as the first argument, this function only returns the name of the current locale for the given category.

This function may be not thread safe because of its reliance on C function setlocale.

os.time ([table])

Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour (default is 12), min (default is 0), sec (default is 0), and isdst (default is nil). For a description of these fields, see the os.date function.

The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the "epoch"). In other systems, the meaning is not specified, and the number returned by time can be used only as an argument to os.date and os.difftime.

os.tmpname ()

Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.

On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).

When possible, you may prefer to use io.tmpfile, which automatically removes the file when the program ends.

6.10 – The Debug Library

This library provides the functionality of the debug interface (§4.9) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.

All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.

debug.debug ()

Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution.

Note that commands for debug.debug are not lexically nested within any function and so have no direct access to local variables.

debug.gethook ([thread])

Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function).

debug.getinfo ([thread,] f [, what])

Returns a table with information about a function. You can give the function directly or you can give a number as the value of f, which means the function running at level f of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo (except for tail calls, which do not count on the stack); and so on. If f is a number larger than the number of active functions, then getinfo returns nil.

The returned table can contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option 'f' adds a field named func with the function itself. If present, the option 'L' adds a field named activelines with the table of valid lines.

For instance, the expression debug.getinfo(1,"n").name returns a table with a name for the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function.

debug.getlocal ([thread,] f, local)

This function returns the name and the value of the local variable with index local of the function at level f of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.

The first parameter or local variable has index 1, and so on, until the last active variable. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns nil if there is no variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.)

Variable names starting with '(' (open parenthesis) represent internal variables (loop control variables, temporaries, varargs, and C function locals).

The parameter f may also be a function. In that case, getlocal returns only the name of function parameters.

debug.getmetatable (value)

Returns the metatable of the given value or nil if it does not have a metatable.

debug.getregistry ()

Returns the registry table (see §4.5).

debug.getupvalue (f, up)

This function returns the name and the value of the upvalue with index up of the function f. The function returns nil if there is no upvalue with the given index.

debug.getuservalue (u)

Returns the Lua value associated to u. If u is not a userdata, returns nil.

debug.sethook ([thread,] hook, mask [, count])

Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:

'c': the hook is called every time Lua calls a function;
'r': the hook is called every time Lua returns from a function;
'l': the hook is called every time Lua enters a new line of code.
Moreover, with a count different from zero, the hook is called also after every count instructions.

When called without arguments, debug.sethook turns off the hook.

When the hook is called, its first parameter is a string describing the event that has triggered its call: "call" (or "tail call"), "return", "line", and "count". For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function).

debug.setlocal ([thread,] level, local, value)

This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable.

See debug.getlocal for more information about variable indices and names.

debug.setmetatable (value, table)

Sets the metatable for the given value to the given table (which can be nil). Returns value.

debug.setupvalue (f, up, value)

This function assigns the value value to the upvalue with index up of the function f. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.

debug.setuservalue (udata, value)

Sets the given value as the Lua value associated to the given udata. value must be a table or nil; udata must be a full userdata.

Returns udata.

debug.traceback ([thread,] [message [, level]])

If message is present but is neither a string nor nil, this function returns message without further processing. Otherwise, it returns a string with a traceback of the call stack. An optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback).

debug.upvalueid (f, n)

Returns an unique identifier (as a light userdata) for the upvalue numbered n from the given function.

These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.

debug.upvaluejoin (f1, n1, f2, n2)

Make the n1-th upvalue of the Lua closure f1 refer to the n2-th upvalue of the Lua closure f2.

7 – Lua Standalone

Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply lua, is provided with the standard distribution. The standalone interpreter includes all standard libraries, including the debug library. Its usage is:

     lua [options] [script [args]]
The options are:

-e stat: executes string stat;
-l mod: "requires" mod;
-i: enters interactive mode after running script;
-v: prints version information;
-E: ignores environment variables;
--: stops handling options;
-: executes stdin as a file and stops handling options.
After handling its options, lua runs the given script, passing to it the given args as string arguments. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise.

When called without option -E, the interpreter checks for an environment variable LUA_INIT_5_2 (or LUA_INIT if it is not defined) before running any argument. If the variable content has the format @filename, then lua executes the file. Otherwise, lua executes the string itself.

When called with option -E, besides ignoring LUA_INIT, Lua also ignores the values of LUA_PATH and LUA_CPATH, setting the values of package.path and package.cpath with the default paths defined in luaconf.h.

All options are handled in order, except -i and -E. For instance, an invocation like

     $ lua -e'a=1' -e 'print(a)' script.lua
will first set a to 1, then print the value of a, and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.)

Before starting to run the script, lua collects all arguments in the command line in a global table called arg. The script name is stored at index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call

     $ lua -la b.lua t1 t2
the interpreter first runs the file a.lua, then creates a table

     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
and finally runs the file b.lua. The script is called with arg[1], arg[2], ... as arguments; it can also access these arguments with the vararg expression '...'.

In interactive mode, if you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.

In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is a string, the interpreter adds a stack traceback to it. Otherwise, if the error object has a metamethod __tostring, the interpreter calls this metamethod to produce the final message. Finally, if the error object is nil, the interpreter does not report the error.

When finishing normally, the interpreter closes its main Lua state (see lua_close). The script can avoid this step by calling os.exit to terminate.

To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in

     #!/usr/local/bin/lua
(Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then

     #!/usr/bin/env lua
is a more portable solution.)

8 – Incompatibilities with the Previous Version

Here we list the incompatibilities that you may find when moving a program from Lua 5.1 to Lua 5.2. You can avoid some incompatibilities by compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the next version of Lua. Similarly, all features marked as deprecated in Lua 5.1 have been removed in Lua 5.2.

8.1 – Changes in the Language

The concept of environment changed. Only Lua functions have environments. To set the environment of a Lua function, use the variable _ENV or the function load.
C functions no longer have environments. Use an upvalue with a shared table if you need to keep shared state among several C functions. (You may use luaL_setfuncs to open a C library with all functions sharing a common upvalue.)

To manipulate the "environment" of a userdata (which is now called user value), use the new functions lua_getuservalue and lua_setuservalue.

Lua identifiers cannot use locale-dependent letters.
Doing a step or a full collection in the garbage collector does not restart the collector if it has been stopped.
Weak tables with weak keys now perform like ephemeron tables.
The event tail return in debug hooks was removed. Instead, tail calls generate a special new event, tail call, so that the debugger can know that there will not be a corresponding return event.
Equality between function values has changed. Now, a function definition may not create a new value; it may reuse some previous value if there is no observable difference to the new function.
8.2 – Changes in the Libraries

Function module is deprecated. It is easy to set up a module with regular Lua code. Modules are not expected to set global variables.
Functions setfenv and getfenv were removed, because of the changes in environments.
Function math.log10 is deprecated. Use math.log with 10 as its second argument, instead.
Function loadstring is deprecated. Use load instead; it now accepts string arguments and are exactly equivalent to loadstring.
Function table.maxn is deprecated. Write it in Lua if you really need it.
Function os.execute now returns true when command terminates successfully and nil plus error information otherwise.
Function unpack was moved into the table library and therefore must be called as table.unpack.
Character class %z in patterns is deprecated, as now patterns may contain '\0' as a regular character.
The table package.loaders was renamed package.searchers.
Lua does not have bytecode verification anymore. So, all functions that load code (load and loadfile) are potentially insecure when loading untrusted binary data. (Actually, those functions were already insecure because of flaws in the verification algorithm.) When in doubt, use the mode argument of those functions to restrict them to loading textual chunks.
The standard paths in the official distribution may change between versions.
8.3 – Changes in the API

Pseudoindex LUA_GLOBALSINDEX was removed. You must get the global environment from the registry (see §4.5).
Pseudoindex LUA_ENVIRONINDEX and functions lua_getfenv/lua_setfenv were removed, as C functions no longer have environments.
Function luaL_register is deprecated. Use luaL_setfuncs so that your module does not create globals. (Modules are not expected to set global variables anymore.)
The osize argument to the allocation function may not be zero when creating a new block, that is, when ptr is NULL (see lua_Alloc). Use only the test ptr == NULL to check whether the block is new.
Finalizers (__gc metamethods) for userdata are called in the reverse order that they were marked for finalization, not that they were created (see §2.5.1). (Most userdata are marked immediately after they are created.) Moreover, if the metatable does not have a __gc field when set, the finalizer will not be called, even if it is set later.
luaL_typerror was removed. Write your own version if you need it.
Function lua_cpcall is deprecated. You can simply push the function with lua_pushcfunction and call it with lua_pcall.
Functions lua_equal and lua_lessthan are deprecated. Use the new lua_compare with appropriate options instead.
Function lua_objlen was renamed lua_rawlen.
Function lua_load has an extra parameter, mode. Pass NULL to simulate the old behavior.
Function lua_resume has an extra parameter, from. Pass NULL or the thread doing the call.
9 – The Complete Syntax of Lua

Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.)


	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  ‘;’ | 
		 varlist ‘=’ explist | 
		 functioncall | 
		 label | 
		 break | 
		 goto Name | 
		 do block end | 
		 while exp do block end | 
		 repeat block until exp | 
		 if exp then block {elseif exp then block} [else block] end | 
		 for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end | 
		 for namelist in explist do block end | 
		 function funcname funcbody | 
		 local function Name funcbody | 
		 local namelist [‘=’ explist] 

	retstat ::= return [explist] [‘;’]

	label ::= ‘::’ Name ‘::’

	funcname ::= Name {‘.’ Name} [‘:’ Name]

	varlist ::= var {‘,’ var}

	var ::=  Name | prefixexp ‘[’ exp ‘]’ | prefixexp ‘.’ Name 

	namelist ::= Name {‘,’ Name}

	explist ::= exp {‘,’ exp}

	exp ::=  nil | false | true | Number | String | ‘...’ | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | ‘(’ exp ‘)’

	functioncall ::=  prefixexp args | prefixexp ‘:’ Name args 

	args ::=  ‘(’ [explist] ‘)’ | tableconstructor | String 

	functiondef ::= function funcbody

	funcbody ::= ‘(’ [parlist] ‘)’ block end

	parlist ::= namelist [‘,’ ‘...’] | ‘...’

	tableconstructor ::= ‘{’ [fieldlist] ‘}’

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= ‘[’ exp ‘]’ ‘=’ exp | Name ‘=’ exp | exp

	fieldsep ::= ‘,’ | ‘;’

	binop ::= ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘^’ | ‘%’ | ‘..’ | 
		 ‘<’ | ‘<=’ | ‘>’ | ‘>=’ | ‘==’ | ‘~=’ | 
		 and | or

	unop ::= ‘-’ | not | ‘#’

